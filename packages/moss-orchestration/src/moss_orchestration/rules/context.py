"""Code context detection.

Automatically classifies code into contexts (test, library, CLI, etc.)
based on structural and path-based heuristics.

Context is used to scope rules - for example, some rules shouldn't
apply to test code, example code, or generated code.
"""

from __future__ import annotations

import ast
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from .base import CodeContext


@dataclass
class ContextHint:
    """A hint about code context with confidence."""

    context: CodeContext
    confidence: float  # 0.0 to 1.0
    reason: str


@dataclass
class ContextDetectorConfig:
    """Configuration for context detection."""

    # Path patterns for each context (regex)
    test_paths: list[str] = field(
        default_factory=lambda: [
            r"/tests?/",
            r"_test\.py$",
            r"test_.*\.py$",
            r"/conftest\.py$",
        ]
    )

    example_paths: list[str] = field(
        default_factory=lambda: [
            r"/examples?/",
            r"/demos?/",
            r"/samples?/",
            r"example.*\.py$",
        ]
    )

    cli_paths: list[str] = field(
        default_factory=lambda: [
            r"/cli\.py$",
            r"/__main__\.py$",
            r"/commands?/",
        ]
    )

    generated_paths: list[str] = field(
        default_factory=lambda: [
            r"/generated/",
            r"_pb2\.py$",  # protobuf
            r"_generated\.py$",
        ]
    )

    config_paths: list[str] = field(
        default_factory=lambda: [
            r"/setup\.py$",
            r"/conftest\.py$",
            r"/settings\.py$",
            r"/config\.py$",
        ]
    )

    # Import patterns that indicate context
    test_imports: list[str] = field(
        default_factory=lambda: [
            "pytest",
            "unittest",
            "hypothesis",
            "nose",
            "mock",
        ]
    )

    # Generated code markers
    generated_markers: list[str] = field(
        default_factory=lambda: [
            "# Generated by",
            "# Auto-generated",
            "# DO NOT EDIT",
            "@generated",
        ]
    )


class ContextDetector:
    """Detects code context from files."""

    def __init__(self, config: ContextDetectorConfig | None = None) -> None:
        self.config = config or ContextDetectorConfig()
        self._compiled_patterns: dict[str, list[re.Pattern[str]]] = {}

    def _get_patterns(self, name: str) -> list[re.Pattern[str]]:
        """Get compiled patterns for a config field."""
        if name not in self._compiled_patterns:
            patterns = getattr(self.config, name, [])
            self._compiled_patterns[name] = [re.compile(p) for p in patterns]
        return self._compiled_patterns[name]

    def detect(self, file_path: Path, source: str | None = None) -> CodeContext:
        """Detect the code context for a file.

        Uses multiple heuristics and returns the most confident match.

        Args:
            file_path: Path to the file
            source: Optional source code (read if not provided)

        Returns:
            Detected CodeContext
        """
        hints = self.get_hints(file_path, source)
        if not hints:
            return CodeContext.LIBRARY

        # Return highest confidence hint
        best = max(hints, key=lambda h: h.confidence)
        return best.context

    def get_hints(self, file_path: Path, source: str | None = None) -> list[ContextHint]:
        """Get all context hints with confidence scores.

        Args:
            file_path: Path to the file
            source: Optional source code

        Returns:
            List of ContextHints sorted by confidence
        """
        hints: list[ContextHint] = []
        path_str = str(file_path)

        # Path-based detection
        hints.extend(self._detect_from_path(path_str))

        # Source-based detection
        if source is None:
            try:
                source = file_path.read_text()
            except (OSError, UnicodeDecodeError):
                source = ""

        if source:
            hints.extend(self._detect_from_source(source))

        # Sort by confidence
        hints.sort(key=lambda h: h.confidence, reverse=True)
        return hints

    def _detect_from_path(self, path: str) -> list[ContextHint]:
        """Detect context from file path."""
        hints: list[ContextHint] = []

        # Extract filename for patterns that should only match filename
        import os

        filename = os.path.basename(path)

        # Check test paths - some patterns are for directories, some for filenames
        for pattern in self._get_patterns("test_paths"):
            pattern_str = pattern.pattern
            # Patterns starting with / are directory patterns - match full path
            # Patterns with \\.py$ are filename patterns - match filename only
            if pattern_str.startswith("/"):
                match_target = path
            elif pattern_str.endswith(r"\.py$"):
                match_target = filename
            else:
                match_target = path

            if pattern.search(match_target):
                hints.append(
                    ContextHint(
                        context=CodeContext.TEST,
                        confidence=0.9,
                        reason=f"Path matches test pattern: {pattern_str}",
                    )
                )
                break

        # Check example paths
        for pattern in self._get_patterns("example_paths"):
            if pattern.search(path):
                hints.append(
                    ContextHint(
                        context=CodeContext.EXAMPLE,
                        confidence=0.9,
                        reason=f"Path matches example pattern: {pattern.pattern}",
                    )
                )
                break

        # Check CLI paths
        for pattern in self._get_patterns("cli_paths"):
            pattern_str = pattern.pattern
            if pattern_str.endswith(r"\.py$"):
                match_target = filename
            else:
                match_target = path

            if pattern.search(match_target):
                hints.append(
                    ContextHint(
                        context=CodeContext.CLI,
                        confidence=0.8,
                        reason=f"Path matches CLI pattern: {pattern_str}",
                    )
                )
                break

        # Check generated paths
        for pattern in self._get_patterns("generated_paths"):
            pattern_str = pattern.pattern
            if pattern_str.endswith(r"\.py$"):
                match_target = filename
            else:
                match_target = path

            if pattern.search(match_target):
                hints.append(
                    ContextHint(
                        context=CodeContext.GENERATED,
                        confidence=0.95,
                        reason=f"Path matches generated pattern: {pattern_str}",
                    )
                )
                break

        # Check config paths
        for pattern in self._get_patterns("config_paths"):
            pattern_str = pattern.pattern
            if pattern_str.endswith(r"\.py$"):
                match_target = filename
            else:
                match_target = path

            if pattern.search(match_target):
                hints.append(
                    ContextHint(
                        context=CodeContext.CONFIG,
                        confidence=0.7,
                        reason=f"Path matches config pattern: {pattern_str}",
                    )
                )
                break

        return hints

    def _detect_from_source(self, source: str) -> list[ContextHint]:
        """Detect context from source code."""
        hints: list[ContextHint] = []

        # Check for generated markers at start of file
        first_lines = "\n".join(source.split("\n")[:10])
        for marker in self.config.generated_markers:
            if marker in first_lines:
                hints.append(
                    ContextHint(
                        context=CodeContext.GENERATED,
                        confidence=0.99,
                        reason=f"Contains generated marker: {marker}",
                    )
                )
                break

        # Parse imports
        try:
            tree = ast.parse(source)
            imports = self._extract_imports(tree)

            # Check for test imports
            for test_import in self.config.test_imports:
                if test_import in imports:
                    hints.append(
                        ContextHint(
                            context=CodeContext.TEST,
                            confidence=0.85,
                            reason=f"Imports test framework: {test_import}",
                        )
                    )
                    break

            # Check for CLI indicators (argparse, click, typer)
            cli_imports = {"argparse", "click", "typer", "fire"}
            if imports & cli_imports:
                hints.append(
                    ContextHint(
                        context=CodeContext.CLI,
                        confidence=0.7,
                        reason=f"Imports CLI library: {imports & cli_imports}",
                    )
                )

        except SyntaxError:
            pass

        return hints

    def _extract_imports(self, tree: ast.AST) -> set[str]:
        """Extract imported module names from AST."""
        imports: set[str] = set()

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name.split(".")[0])
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module.split(".")[0])

        return imports


# Default detector instance
_default_detector: ContextDetector | None = None


def get_default_detector() -> ContextDetector:
    """Get the default context detector."""
    global _default_detector
    if _default_detector is None:
        _default_detector = ContextDetector()
    return _default_detector


def detect_context(file_path: Path, source: str | None = None) -> CodeContext:
    """Detect code context for a file using the default detector."""
    return get_default_detector().detect(file_path, source)


def configure_detector(config: ContextDetectorConfig | dict[str, Any]) -> None:
    """Configure the default context detector.

    Args:
        config: ContextDetectorConfig or dict with config values
    """
    global _default_detector

    if isinstance(config, dict):
        config = ContextDetectorConfig(**config)

    _default_detector = ContextDetector(config)
