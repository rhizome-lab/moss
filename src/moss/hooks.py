"""Pre-commit hook integration for Moss.

This module provides integration with git pre-commit hooks, allowing
automatic code analysis before commits.

Usage:
    from moss.hooks import install_hooks, generate_hook_config

    # Install hooks directly
    install_hooks(project_dir)

    # Generate pre-commit config
    config = generate_hook_config()
"""

from __future__ import annotations

from pathlib import Path
from typing import Any

# Pre-commit hook script template
HOOK_SCRIPT = """#!/bin/sh
# Moss pre-commit hook
# Auto-generated by moss hooks install

# Get list of staged Python files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\\.py$')

if [ -z "$STAGED_FILES" ]; then
    exit 0
fi

# Run moss checks
echo "Running Moss pre-commit checks..."

# Check if moss is available
if ! command -v moss &> /dev/null; then
    # Try running as module
    if ! python -m moss --version &> /dev/null; then
        echo "Warning: moss not found, skipping pre-commit checks"
        exit 0
    fi
    MOSS_CMD="python -m moss"
else
    MOSS_CMD="moss"
fi

# Run skeleton check to validate syntax
for file in $STAGED_FILES; do
    if [ -f "$file" ]; then
        $MOSS_CMD skeleton "$file" --quiet
        if [ $? -ne 0 ]; then
            echo "Moss check failed for: $file"
            exit 1
        fi
    fi
done

echo "Moss pre-commit checks passed!"
exit 0
"""

# Pre-commit config template for .pre-commit-config.yaml
PRE_COMMIT_CONFIG = {
    "repos": [
        {
            "repo": "local",
            "hooks": [
                {
                    "id": "moss-skeleton",
                    "name": "Moss Skeleton Check",
                    "entry": "moss skeleton --quiet",
                    "language": "system",
                    "types": ["python"],
                    "pass_filenames": True,
                },
                {
                    "id": "moss-deps",
                    "name": "Moss Dependency Check",
                    "entry": "moss deps --quiet",
                    "language": "system",
                    "types": ["python"],
                    "pass_filenames": True,
                },
            ],
        }
    ]
}


def install_hooks(project_dir: Path, force: bool = False) -> bool:
    """Install git pre-commit hooks.

    Args:
        project_dir: Project root directory (must contain .git)
        force: Overwrite existing hooks

    Returns:
        True if hooks were installed successfully

    Raises:
        FileNotFoundError: If .git directory doesn't exist
        FileExistsError: If hooks exist and force is False
    """
    git_dir = project_dir / ".git"
    if not git_dir.exists():
        raise FileNotFoundError(f"Not a git repository: {project_dir}")

    hooks_dir = git_dir / "hooks"
    hooks_dir.mkdir(exist_ok=True)

    pre_commit_hook = hooks_dir / "pre-commit"

    if pre_commit_hook.exists() and not force:
        raise FileExistsError(
            f"Pre-commit hook already exists: {pre_commit_hook}. Use --force to overwrite."
        )

    # Write hook script
    pre_commit_hook.write_text(HOOK_SCRIPT)
    pre_commit_hook.chmod(0o755)

    return True


def uninstall_hooks(project_dir: Path) -> bool:
    """Uninstall git pre-commit hooks.

    Args:
        project_dir: Project root directory

    Returns:
        True if hooks were uninstalled successfully
    """
    git_dir = project_dir / ".git"
    if not git_dir.exists():
        return False

    pre_commit_hook = git_dir / "hooks" / "pre-commit"

    if pre_commit_hook.exists():
        # Check if it's our hook
        content = pre_commit_hook.read_text()
        if "Moss pre-commit hook" in content:
            pre_commit_hook.unlink()
            return True

    return False


def generate_hook_config() -> dict[str, Any]:
    """Generate pre-commit config for use with pre-commit framework.

    Returns:
        Configuration dictionary for .pre-commit-config.yaml
    """
    return PRE_COMMIT_CONFIG.copy()


def generate_hook_config_yaml() -> str:
    """Generate pre-commit config as YAML string.

    Returns:
        YAML-formatted configuration string
    """
    import yaml

    return yaml.dump(PRE_COMMIT_CONFIG, default_flow_style=False, sort_keys=False)


def check_hooks_installed(project_dir: Path) -> bool:
    """Check if moss hooks are installed.

    Args:
        project_dir: Project root directory

    Returns:
        True if moss hooks are installed
    """
    git_dir = project_dir / ".git"
    if not git_dir.exists():
        return False

    pre_commit_hook = git_dir / "hooks" / "pre-commit"
    if not pre_commit_hook.exists():
        return False

    content = pre_commit_hook.read_text()
    return "Moss pre-commit hook" in content


def get_staged_files(project_dir: Path) -> list[Path]:
    """Get list of staged Python files.

    Args:
        project_dir: Project root directory

    Returns:
        List of staged Python file paths
    """
    import subprocess

    try:
        result = subprocess.run(
            ["git", "diff", "--cached", "--name-only", "--diff-filter=ACM"],
            capture_output=True,
            text=True,
            cwd=project_dir,
            check=True,
        )
        files = []
        for line in result.stdout.strip().split("\n"):
            if line and line.endswith(".py"):
                files.append(project_dir / line)
        return files
    except subprocess.CalledProcessError:
        return []


def run_pre_commit_checks(project_dir: Path) -> tuple[bool, list[str]]:
    """Run pre-commit checks on staged files.

    Args:
        project_dir: Project root directory

    Returns:
        Tuple of (success, list of error messages)
    """
    import asyncio

    from moss.plugins import get_registry
    from moss.views import ViewTarget

    staged_files = get_staged_files(project_dir)
    if not staged_files:
        return True, []

    errors: list[str] = []
    registry = get_registry()

    async def check_file(file_path: Path) -> str | None:
        """Check a single file."""
        if not file_path.exists():
            return None

        target = ViewTarget(path=file_path)
        plugin = registry.find_plugin(target, "skeleton")

        if plugin is None:
            return None

        try:
            view = await plugin.render(target)
            if "error" in view.metadata:
                return f"{file_path}: {view.metadata['error']}"
        except Exception as e:
            return f"{file_path}: {e}"

        return None

    async def check_all() -> list[str]:
        results = []
        for f in staged_files:
            error = await check_file(f)
            if error:
                results.append(error)
        return results

    errors = asyncio.run(check_all())
    return len(errors) == 0, errors
