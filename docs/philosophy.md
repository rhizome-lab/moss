# Moss Philosophy

This document contains the design philosophy and architectural overview for Moss.
For behavioral rules and conventions, see `CLAUDE.md`.

## Project Overview

Moss is tooling orchestration with structural awareness. It implements a "Compiled Context" approach that prioritizes architectural awareness (AST-based understanding) over raw text processing, with verification loops ensuring correctness before output.

## Architecture

Core components:
- **Event Bus**: Async communication (`UserMessage`, `PlanGenerated`, `ToolCall`, `ValidationFailed`, `ShadowCommit`)
- **Context Host**: Manages View Providers (Skeleton, CFG, Dependency Graph) - delegates to plugins
- **Structural Editor**: AST-based editing with fuzzy anchor matching
- **Policy Engine**: Enforces safety rules (velocity checks, quarantine)
- **Validator**: Domain-specific verification loop (compiler, linter, tests)
- **Shadow Git**: Atomic commits per tool call, rollback via git reset

Data flow: User Request → Config Engine → Planner → Context Host (Views) → Draft → Shadow Git → Validator → (retry loop if error) → Commit Handle

Multi-agent model: Ticket-based (not shared chat history). Agents are isolated microservices passing Handles, not context.

See `docs/spec.md` for the full specification.

## Design Tenets

### Minimize LLM Usage

LLM calls are expensive (cost) and slow (latency). Design everything to reduce them:
- Structural tools first: Use AST, grep, validation - not LLM - for deterministic tasks
- LLM only for judgment: Generation, decisions, ambiguity resolution
- Measure separately: Track LLM calls vs tool calls in benchmarks
- Cache aggressively: Same query → same answer (where applicable)

This is why we have skeleton views (understand code without LLM), validation loops (catch errors without LLM), and DWIM (find tools without LLM). The goal: an agent that calls the LLM 10x less than naive approaches.

### Prompt Engineering for Token Efficiency

When you do call an LLM, minimize output tokens. Our system prompt in `src/moss/agent_loop.py` explicitly forbids:
- Preamble and summary
- Markdown formatting (bold, headers, code blocks unless asked)
- More than 5 bullet points for analysis

Result: 12x reduction in output tokens (1421 → 112) with same quality insights.

### Hyper-Modular Architecture

Prefer many small, focused modules over fewer large ones:
- Maintainability: Easier to understand, modify, and test small units
- Composability: Small pieces combine flexibly
- Refactorability: Can restructure without rewriting everything

### Library-First Design

The core should be an importable Python library. Interfaces (CLI, HTTP, MCP, LSP) are wrappers around the library, ideally autogenerated from the API via introspection.

### Everything is a Plugin

Where possible, use plugin protocols instead of hardcoded implementations. Even "native" integrations should implement the same plugin interface as third-party ones.

### Maximally Useful Defaults

Every configurable option should have a default that:
- Works well for the common case (80% of users shouldn't need to configure it)
- Errs on the side of usefulness over safety-theater
- Can be discovered and changed when needed

### Good Defaults, Fast Specialization

Good defaults mean acceptable general performance out of the box. But we should absolutely support hyper-specialization for those who want it:
- **Quick wins first**: Default config should "just work" reasonably well
- **Escape hatches**: When defaults aren't enough, specialization should be one step away
- **Zero-to-custom fast**: The path from "using defaults" to "fully customized" should be short and obvious
- **No ceiling**: Power users shouldn't hit walls. If someone wants to optimize for their exact workflow, let them

This is a conscious tradeoff: defaults optimize for breadth (works for everyone), specialization optimizes for depth (works perfectly for you). Both are valid, and the system should excel at both ends of the spectrum.

### Low Barrier to Entry

Make it easy to get started:
- Works out of the box with minimal configuration
- Sensible defaults for common workflows
- Progressive disclosure: simple things simple, complex things possible
- Clear error messages that guide users toward solutions

### DWIM (Do What I Mean)

Agents make mistakes - typos, wrong conventions, forgotten paths. Every lookup should be forgiving:
- Fuzzy file resolution: `prior_art` finds `prior-art.md`
- Symbol search tolerates partial names and typos
- Tool selection handles aliases and misspellings
- Pattern: try exact → try fuzzy → try corrections → ask for clarification

### Works on Messy Codebases

Real-world code is often messy. Moss should:
- Handle legacy code without requiring refactoring first
- Degrade gracefully when AST parsing fails (text fallbacks)
- Support incremental improvement (clean up as you go, or don't)
- Not impose architectural opinions unless asked

### Workflows Become Presets

If you have a workflow, the intuitive way to proceed should be to codify it. Custom presets are first-class citizens:
- **Capture patterns**: Repeated sequences of actions should become single commands
- **User-defined skills**: `.moss/skills/` for domain-specific behaviors
- **Progressive formalization**: Start ad-hoc, graduate to preset when patterns emerge
- **Shareable**: Presets should be easy to share, version, and compose

The goal: reduce the distance between "I do this often" and "now it's a command."

### Accelerate Vibe Coding

Maximize useful work per token. Minimize friction in the creative flow:
- **Token efficiency**: Never send full code when a skeleton suffices. Compress context. Use structured output parsing instead of free-form text
- **Minimal LLM calls**: Use structural tools (AST, grep, validation) for deterministic tasks. LLM only for judgment
- **Parallelism**: Run independent operations concurrently. Batch when possible
- **Fast feedback loops**: Validation before commit, not after. Catch errors early
- **Minimize error rate**: Avoid wasted retry cycles. Get it right the first time
- **Usefulness per token**: Avoid busywork. Every action should move toward the goal
- **Future goal**: Diff-based editing to avoid sending unchanged code
