# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Core Rule

**ALWAYS NOTE THINGS DOWN.** The worst thing that can happen is forgetting. When you discover something important - a bug, a design decision, a naming collision, a future improvement - write it down immediately in the appropriate place:
- Bugs/issues → fix them or add to TODO.md
- Design decisions → docs/ or code comments
- Future work → TODO.md
- Conventions → this file (CLAUDE.md)

## Project Overview

Moss is tooling orchestration with structural awareness. It implements a "Compiled Context" approach that prioritizes architectural awareness (AST-based understanding) over raw text processing, with verification loops ensuring correctness before output.

## Development Environment

This project uses Nix flakes for reproducible development environments:

```bash
# Enter dev shell (automatic with direnv, or manual)
nix develop

# Tools available: Python 3.13, uv, ruff, ripgrep
```

## Architecture (from docs/spec.md)

Core components:
- **Event Bus**: Async communication (`UserMessage`, `PlanGenerated`, `ToolCall`, `ValidationFailed`, `ShadowCommit`)
- **Context Host**: Manages View Providers (Skeleton, CFG, Dependency Graph) - delegates to plugins
- **Structural Editor**: AST-based editing with fuzzy anchor matching
- **Policy Engine**: Enforces safety rules (velocity checks, quarantine)
- **Validator**: Domain-specific verification loop (compiler, linter, tests)
- **Shadow Git**: Atomic commits per tool call, rollback via git reset

Data flow: User Request → Config Engine → Planner → Context Host (Views) → Draft → Shadow Git → Validator → (retry loop if error) → Commit Handle

Multi-agent model: Ticket-based (not shared chat history). Agents are isolated microservices passing Handles, not context.

## Design Paradigm

**Hyper-modular architecture.** Prefer many small, focused modules over fewer large ones. This aids:
- **Maintainability**: Easier to understand, modify, and test small units
- **Composability**: Small pieces combine flexibly
- **Refactorability**: Can restructure without rewriting everything

**Library-first design.** The core should be an importable Python library. Interfaces (CLI, HTTP, MCP, LSP) are wrappers around the library, ideally autogenerated from the API via introspection.

**Everything is a plugin.** Where possible, use plugin protocols instead of hardcoded implementations. Even "native" integrations should implement the same plugin interface as third-party ones.

**Server as API.** The server is the canonical API surface; CLI and TUI are frontends to the server, not the other way around.

## Conventions

### Working Style

**Agentic by default.** Prefer an indefinite agentic loop - continue working through tasks autonomously, including committing work, unless instructed otherwise.

**Bail out early.** If you hit repeated failures or get stuck in a loop, stop and ask for guidance rather than burning tokens on increasingly unlikely fixes.

### Commits

**Commit consistently.** Don't leave work uncommitted - always commit when a logical unit of work is complete.

Each commit should be a **unit of work** - a single logical change that could be reverted independently. Not "fixed stuff" but "fix: handle null response in validator loop".

### Code Quality

Linting: `ruff check` and `ruff format` (enforced once CI exists)

### Testing Strategy

Tests at all levels:
- **Unit**: Isolated component behavior
- **Integration**: Component interactions (e.g., Context Host ↔ Validator)
- **E2E**: Full flows (user request → commit handle)
- **Fuzzing**: Malformed inputs, edge cases in AST parsing

Run tests before committing. When adding functionality, add corresponding tests.
