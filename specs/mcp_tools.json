[
  {
    "name": "skeleton_expand_symbol",
    "description": "Get the full source code of a named symbol. Useful for getting complete enum definitions, class bodies, or function implementations when the skeleton isn't enough. Full source code of the symbol, or None if not found # Get full enum definition content = expand_symbol(source, \"StepType\") # Returns: # class StepType(Enum): #     TOOL = auto() #     LLM = auto() #     HYBRID = auto()",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string",
          "description": "Python source code"
        },
        "symbol_name": {
          "type": "string",
          "description": "Name of the symbol to expand (e.g., \"StepType\", \"my_function\")"
        }
      },
      "required": [
        "source",
        "symbol_name"
      ]
    }
  },
  {
    "name": "skeleton_extract_python_skeleton",
    "description": "Convenience function to extract skeleton from Python source.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "include_private": {
          "type": "boolean",
          "default": false
        }
      },
      "required": [
        "source"
      ]
    }
  },
  {
    "name": "skeleton_format_skeleton",
    "description": "Format symbols as skeleton text.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "symbols": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "include_docstrings": {
          "type": "boolean",
          "default": true
        },
        "indent": {
          "type": "integer",
          "default": 0
        }
      },
      "required": [
        "symbols"
      ]
    }
  },
  {
    "name": "skeleton_get_enum_values",
    "description": "Extract enum member names from an Enum class. List of enum member names, or None if not found values = get_enum_values(source, \"StepType\") # Returns: [\"TOOL\", \"LLM\", \"HYBRID\"]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string",
          "description": "Python source code"
        },
        "enum_name": {
          "type": "string",
          "description": "Name of the Enum class"
        }
      },
      "required": [
        "source",
        "enum_name"
      ]
    }
  },
  {
    "name": "skeleton_query_symbols",
    "description": "Query symbols in files matching a pattern. List of QueryResult objects matching the filters",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "File or directory to search"
        },
        "pattern": {
          "type": "string",
          "description": "Glob pattern for files (default: **/*.py)",
          "default": "**/*.py"
        },
        "kind": {
          "type": "string",
          "description": "Filter by symbol kind (class, function, method)"
        },
        "name": {
          "type": "string",
          "description": "Filter by name (regex pattern)"
        },
        "signature": {
          "type": "string",
          "description": "Filter by signature (regex pattern)"
        },
        "inherits": {
          "type": "string",
          "description": "Filter classes by base class name"
        },
        "min_lines": {
          "type": "string",
          "description": "Minimum lines in symbol"
        },
        "max_lines": {
          "type": "string",
          "description": "Maximum lines in symbol"
        }
      },
      "required": [
        "path"
      ]
    }
  },
  {
    "name": "anchors_find_anchors",
    "description": "Find all matches for an anchor in source code.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "anchor": {
          "type": "string"
        },
        "min_score": {
          "type": "number",
          "default": 0.6
        }
      },
      "required": [
        "source",
        "anchor"
      ]
    }
  },
  {
    "name": "anchors_resolve_anchor",
    "description": "Convenience function to resolve an anchor in source code.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "anchor": {
          "type": "string"
        },
        "min_score": {
          "type": "number",
          "default": 0.6
        }
      },
      "required": [
        "source",
        "anchor"
      ]
    }
  },
  {
    "name": "patches_apply_patch",
    "description": "Apply a patch to source code. PatchResult with success status and patched code",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string",
          "description": "Original source code"
        },
        "patch": {
          "type": "string",
          "description": "The patch to apply"
        },
        "min_score": {
          "type": "number",
          "description": "Minimum anchor match score",
          "default": 0.6
        }
      },
      "required": [
        "source",
        "patch"
      ]
    }
  },
  {
    "name": "patches_apply_patch_with_fallback",
    "description": "Try AST-based patch, fall back to text if AST is broken. PatchResult with success status and patched code",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string",
          "description": "Original source code"
        },
        "patch": {
          "type": "string",
          "description": "The AST-based patch to try first"
        },
        "fallback_search": {
          "type": "string",
          "description": "Text to search for if AST fails"
        },
        "fallback_replace": {
          "type": "string",
          "description": "Replacement text if AST fails"
        }
      },
      "required": [
        "source",
        "patch"
      ]
    }
  },
  {
    "name": "patches_apply_text_patch",
    "description": "Apply a text-based patch (fallback for broken AST). PatchResult with success status and patched code",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string",
          "description": "Original source code"
        },
        "search": {
          "type": "string",
          "description": "Text to search for"
        },
        "replace": {
          "type": "string",
          "description": "Replacement text"
        },
        "occurrence": {
          "type": "integer",
          "description": "Which occurrence to replace (1-indexed, 0 for all)",
          "default": 1
        }
      },
      "required": [
        "source",
        "search",
        "replace"
      ]
    }
  },
  {
    "name": "tree_build_tree",
    "description": "Build a tree structure from a list of file paths.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "files": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "files"
      ]
    }
  },
  {
    "name": "tree_generate_tree",
    "description": "Generate a tree visualization of a directory. TreeResult with tree visualization and statistics",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Root directory to visualize"
        },
        "tracked_only": {
          "type": "boolean",
          "description": "If True, only show git-tracked files",
          "default": false
        },
        "gitignore": {
          "type": "boolean",
          "description": "If True, respect .gitignore when showing all files",
          "default": true
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "tree_get_all_files",
    "description": "Get all files, optionally respecting .gitignore.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "File or directory path"
        },
        "gitignore": {
          "type": "boolean",
          "default": true
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "tree_get_git_tracked_files",
    "description": "Get list of git-tracked files relative to root.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "File or directory path"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "tree_render_tree",
    "description": "Render tree to lines of text.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "node": {
          "type": "string"
        },
        "prefix": {
          "type": "string",
          "default": ""
        },
        "is_last": {
          "type": "boolean",
          "default": true
        },
        "is_root": {
          "type": "boolean",
          "default": true
        }
      },
      "required": [
        "node"
      ]
    }
  },
  {
    "name": "views_create_default_registry",
    "description": "Create a registry with default providers.",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "cfg_build_cfg",
    "description": "Convenience function to build CFGs from source. List of ControlFlowGraph objects",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string",
          "description": "Python source code"
        },
        "function_name": {
          "type": "string",
          "description": "Specific function (None for all)"
        }
      },
      "required": [
        "source"
      ]
    }
  },
  {
    "name": "dependencies_build_dependency_graph",
    "description": "Build a dependency graph from a directory of Python files. Dict mapping module paths to list of imported modules",
    "inputSchema": {
      "type": "object",
      "properties": {
        "search_path": {
          "type": "string",
          "description": "Directory to scan"
        },
        "pattern": {
          "type": "string",
          "description": "Glob pattern for files",
          "default": "**/*.py"
        },
        "internal_only": {
          "type": "boolean",
          "description": "If True, only include imports within the search_path",
          "default": true
        }
      },
      "required": [
        "search_path"
      ]
    }
  },
  {
    "name": "dependencies_dependency_graph_to_dot",
    "description": "Convert a dependency graph to DOT format. DOT format string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "graph": {
          "type": "object",
          "description": "Dict mapping modules to their imports"
        },
        "title": {
          "type": "string",
          "description": "Title for the graph",
          "default": "Dependencies"
        }
      },
      "required": [
        "graph"
      ]
    }
  },
  {
    "name": "dependencies_expand_import_context",
    "description": "Expand imports to their skeleton context. This implements Phases 1 & 3 of \"File Boundaries Don't Exist\": imports ARE context, automatically include skeleton of imported symbols. Dict mapping \"module:symbol\" to skeleton text >>> context = expand_import_context(Path(\"api.py\"), Path(\".\")) >>> print(context[\"models:User\"]) class User: id: int email: str def validate(self) -> bool: ... # With depth=2, also includes types referenced by User >>> context = expand_import_context(Path(\"api.py\"), Path(\".\"), depth=2)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": {
          "type": "string",
          "description": "Path to the file to analyze"
        },
        "root": {
          "type": "string",
          "description": "Project root directory"
        },
        "symbols_only": {
          "type": "boolean",
          "description": "If True, only include imported symbols (not full module)",
          "default": true
        },
        "depth": {
          "type": "integer",
          "description": "How many levels of transitive imports to follow (default 1)",
          "default": 1
        },
        "_visited": {
          "type": "string",
          "description": "Internal - tracks visited files to prevent cycles"
        }
      },
      "required": [
        "file_path",
        "root"
      ]
    }
  },
  {
    "name": "dependencies_extract_dependencies",
    "description": "Extract dependencies from Python source.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        }
      },
      "required": [
        "source"
      ]
    }
  },
  {
    "name": "dependencies_find_reverse_dependencies",
    "description": "Find all files that import a target module. List of ReverseDependency showing files that import the target",
    "inputSchema": {
      "type": "object",
      "properties": {
        "target_module": {
          "type": "string",
          "description": "Module name to search for (e.g., \"moss.skeleton\")"
        },
        "search_path": {
          "type": "string",
          "description": "Directory to search in"
        },
        "pattern": {
          "type": "string",
          "description": "Glob pattern for files to search",
          "default": "**/*.py"
        }
      },
      "required": [
        "target_module",
        "search_path"
      ]
    }
  },
  {
    "name": "dependencies_format_available_modules",
    "description": "Format available modules as compact text. Formatted text suitable for LLM context",
    "inputSchema": {
      "type": "object",
      "properties": {
        "available": {
          "type": "object",
          "description": "Dict from get_available_modules()"
        },
        "max_symbols": {
          "type": "integer",
          "description": "Max symbols to show per module before truncating",
          "default": 8
        }
      },
      "required": [
        "available"
      ]
    }
  },
  {
    "name": "dependencies_format_dependencies",
    "description": "Format dependency info as text.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "info": {
          "type": "string"
        },
        "include_exports": {
          "type": "boolean",
          "default": true
        }
      },
      "required": [
        "info"
      ]
    }
  },
  {
    "name": "dependencies_format_import_context",
    "description": "Format expanded import context as text. Formatted text suitable for LLM context",
    "inputSchema": {
      "type": "object",
      "properties": {
        "context": {
          "type": "object",
          "description": "Dict from expand_import_context()"
        }
      },
      "required": [
        "context"
      ]
    }
  },
  {
    "name": "dependencies_get_available_modules",
    "description": "Get available modules and their exports in the same package. This implements Phase 2 of \"File Boundaries Don't Exist\": show what's importable BEFORE the agent writes code. Dict mapping module name to list of exported symbol names >>> available = get_available_modules(Path(\"mypackage/api.py\"), Path(\".\")) >>> print(available) {'models': ['User', 'Session'], 'auth': ['verify_token', 'create_token']}",
    "inputSchema": {
      "type": "object",
      "properties": {
        "file_path": {
          "type": "string",
          "description": "Path to the current file"
        },
        "root": {
          "type": "string",
          "description": "Project root directory"
        }
      },
      "required": [
        "file_path",
        "root"
      ]
    }
  },
  {
    "name": "dependencies_resolve_relative_import",
    "description": "Resolve a relative import to an actual file path. Path to the imported module, or None if not found",
    "inputSchema": {
      "type": "object",
      "properties": {
        "import_info": {
          "type": "string",
          "description": "The import to resolve"
        },
        "current_file": {
          "type": "string",
          "description": "Path of the file containing the import"
        },
        "root": {
          "type": "string",
          "description": "Project root directory"
        }
      },
      "required": [
        "import_info",
        "current_file",
        "root"
      ]
    }
  },
  {
    "name": "complexity_analyze_complexity",
    "description": "Convenience function to analyze cyclomatic complexity. ComplexityReport with complexity data",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Path to the project root"
        },
        "pattern": {
          "type": "string",
          "description": "Glob pattern for files to analyze",
          "default": "**/*.py"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "security_analyze_security",
    "description": "Convenience function to run security analysis. SecurityAnalysis with findings",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        },
        "tools": {
          "type": "string",
          "description": "List of tool names (None = all available)"
        },
        "min_severity": {
          "type": "string",
          "description": "Minimum severity (\"low\", \"medium\", \"high\", \"critical\")",
          "default": "low"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "security_format_security_analysis",
    "description": "Format security analysis as markdown.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "analysis": {
          "type": "string"
        }
      },
      "required": [
        "analysis"
      ]
    }
  },
  {
    "name": "clones_detect_clones",
    "description": "Convenience function to detect clones. CloneAnalysis with detected clone groups",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        },
        "level": {
          "type": "string",
          "description": "Elision level (0-3) for normalization",
          "default": 0
        },
        "min_lines": {
          "type": "integer",
          "description": "Minimum function lines to consider",
          "default": 3
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "clones_format_clone_analysis",
    "description": "Format clone analysis results as markdown.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "analysis": {
          "type": "string",
          "description": "Clone analysis results"
        },
        "show_source": {
          "type": "boolean",
          "description": "Whether to include source code snippets",
          "default": false
        },
        "root": {
          "type": "string",
          "description": "Project root for computing relative paths (defaults to showing file names only)"
        }
      },
      "required": [
        "analysis"
      ]
    }
  },
  {
    "name": "clones_get_function_source",
    "description": "Extract source code for a function node.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "source": {
          "type": "string"
        },
        "node": {
          "type": "string"
        }
      },
      "required": [
        "source",
        "node"
      ]
    }
  },
  {
    "name": "clones_hash_ast",
    "description": "Compute a hash of an AST node's structure.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "node": {
          "type": "string"
        }
      },
      "required": [
        "node"
      ]
    }
  },
  {
    "name": "clones_normalize_ast",
    "description": "Normalize an AST node at the given elision level.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "node": {
          "type": "string"
        },
        "level": {
          "type": "string"
        }
      },
      "required": [
        "node",
        "level"
      ]
    }
  },
  {
    "name": "diagnostics_clean_output",
    "description": "Clean compiler output by removing noise.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ]
    }
  },
  {
    "name": "diagnostics_get_structured_command",
    "description": "Get command-line flags for structured output. List of flags to add for structured output",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tool": {
          "type": "string",
          "description": "Tool name (e.g., 'cargo', 'eslint', 'ruff')"
        }
      },
      "required": [
        "tool"
      ]
    }
  },
  {
    "name": "diagnostics_is_noise_line",
    "description": "Check if a line is visual noise (ASCII art, decorations).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "line": {
          "type": "string"
        }
      },
      "required": [
        "line"
      ]
    }
  },
  {
    "name": "diagnostics_parse_diagnostics",
    "description": "Parse diagnostic output. DiagnosticSet with parsed diagnostics",
    "inputSchema": {
      "type": "object",
      "properties": {
        "output": {
          "type": "string",
          "description": "Raw compiler/linter output"
        },
        "parser": {
          "type": "string",
          "description": "Optional parser name to force (e.g., 'cargo', 'eslint')"
        }
      },
      "required": [
        "output"
      ]
    }
  },
  {
    "name": "diagnostics_strip_ansi",
    "description": "Remove ANSI escape sequences from text.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string"
        }
      },
      "required": [
        "text"
      ]
    }
  },
  {
    "name": "weaknesses_analyze_weaknesses",
    "description": "Convenience function to analyze weaknesses. WeaknessAnalysis with detected weaknesses",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        },
        "categories": {
          "type": "string",
          "description": "Categories to check (None = all)"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "weaknesses_format_weakness_analysis",
    "description": "Format weakness analysis as markdown.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "analysis": {
          "type": "string"
        }
      },
      "required": [
        "analysis"
      ]
    }
  },
  {
    "name": "weaknesses_format_weakness_fixes",
    "description": "Format weakness fixes as markdown.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fixes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "fixes"
      ]
    }
  },
  {
    "name": "weaknesses_generate_sarif_from_weaknesses",
    "description": "Generate SARIF output from weakness analysis. SARIF (Static Analysis Results Interchange Format) is a standard for static analysis results supported by GitHub, Azure DevOps, etc. SARIF document as dictionary",
    "inputSchema": {
      "type": "object",
      "properties": {
        "analysis": {
          "type": "string",
          "description": "Weakness analysis result"
        },
        "tool_name": {
          "type": "string",
          "description": "Name for the tool component",
          "default": "moss-weaknesses"
        },
        "tool_version": {
          "type": "string",
          "description": "Tool version string",
          "default": "0.1.0"
        }
      },
      "required": [
        "analysis"
      ]
    }
  },
  {
    "name": "weaknesses_get_fixable_weaknesses",
    "description": "Get weaknesses that have automated or semi-automated fixes. List of WeaknessFix objects for fixable weaknesses",
    "inputSchema": {
      "type": "object",
      "properties": {
        "analysis": {
          "type": "string"
        }
      },
      "required": [
        "analysis"
      ]
    }
  },
  {
    "name": "weaknesses_weaknesses_to_sarif",
    "description": "Generate SARIF JSON from weakness analysis. SARIF JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "analysis": {
          "type": "string",
          "description": "Weakness analysis result"
        },
        "output_path": {
          "type": "string",
          "description": "Optional path to write SARIF file"
        },
        "tool_name": {
          "type": "string",
          "description": "Name for the tool component",
          "default": "moss-weaknesses"
        },
        "tool_version": {
          "type": "string",
          "description": "Tool version string",
          "default": "0.1.0"
        }
      },
      "required": [
        "analysis"
      ]
    }
  },
  {
    "name": "edit_analyze_complexity",
    "description": "Determine task complexity based on description and context. TaskComplexity level",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string",
          "description": "Task description"
        },
        "context": {
          "type": "string",
          "description": "Edit context with project info"
        }
      },
      "required": [
        "task",
        "context"
      ]
    }
  },
  {
    "name": "edit_edit",
    "description": "Edit code with intelligent routing based on complexity. Routes to appropriate handler: - Simple tasks \u2192 structural editing (refactoring) - Medium tasks \u2192 multi-agent decomposition - Complex/novel tasks \u2192 synthesis EditResult with changes and metadata",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string",
          "description": "Task description (what to do)"
        },
        "context": {
          "type": "string",
          "description": "Edit context (where to do it)"
        }
      },
      "required": [
        "task",
        "context"
      ]
    }
  },
  {
    "name": "edit_extract_specification",
    "description": "Extract a synthesis specification from task description. Specification for synthesis",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string",
          "description": "Task description"
        },
        "context": {
          "type": "string",
          "description": "Edit context"
        }
      },
      "required": [
        "task",
        "context"
      ]
    }
  },
  {
    "name": "edit_is_direct_edit",
    "description": "Check if task is a direct edit (simple).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string"
        }
      },
      "required": [
        "task"
      ]
    }
  },
  {
    "name": "edit_is_localized_change",
    "description": "Check if task is a localized change (medium).",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string"
        }
      },
      "required": [
        "task"
      ]
    }
  },
  {
    "name": "edit_is_multi_file_change",
    "description": "Check if task affects multiple files.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string"
        }
      },
      "required": [
        "task"
      ]
    }
  },
  {
    "name": "edit_is_new_feature",
    "description": "Check if task is a new feature.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string"
        }
      },
      "required": [
        "task"
      ]
    }
  },
  {
    "name": "edit_is_novel_problem",
    "description": "Check if task is a novel problem requiring design.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string"
        }
      },
      "required": [
        "task"
      ]
    }
  },
  {
    "name": "edit_multi_agent_edit",
    "description": "Handle medium complexity edits using multi-agent decomposition. Medium edits include: - Adding new functions/methods/classes - Refactoring existing code - Extracting or inlining code - Adding logging/error handling EditResult with changes",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string",
          "description": "Task description"
        },
        "context": {
          "type": "string",
          "description": "Edit context"
        }
      },
      "required": [
        "task",
        "context"
      ]
    }
  },
  {
    "name": "edit_structural_edit",
    "description": "Handle simple structural edits using refactoring tools. Simple edits include: - Renaming symbols - Fixing typos - Updating comments/docstrings - Removing unused code - Adding imports EditResult with changes",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string",
          "description": "Task description"
        },
        "context": {
          "type": "string",
          "description": "Edit context"
        }
      },
      "required": [
        "task",
        "context"
      ]
    }
  },
  {
    "name": "edit_synthesize_edit",
    "description": "Handle complex edits using synthesis. Complex/novel edits include: - Implementing new features - Creating APIs/services - Rewriting/optimizing code - Novel designs EditResult with synthesized code",
    "inputSchema": {
      "type": "object",
      "properties": {
        "task": {
          "type": "string",
          "description": "Task description"
        },
        "context": {
          "type": "string",
          "description": "Edit context"
        }
      },
      "required": [
        "task",
        "context"
      ]
    }
  },
  {
    "name": "scopes_analyze_file_scopes",
    "description": "Analyze scope statistics for a single Python file. FileScopeReport with public/private statistics",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Path to the Python file"
        }
      },
      "required": [
        "path"
      ]
    }
  },
  {
    "name": "scopes_analyze_project_scopes",
    "description": "Analyze scope statistics for a project. ProjectScopeReport with aggregated statistics",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        },
        "pattern": {
          "type": "string",
          "description": "Glob pattern for Python files",
          "default": "**/*.py"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "scopes_format_scope_report",
    "description": "Format a scope report as human-readable text. Formatted string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "report": {
          "type": "string",
          "description": "File or project scope report"
        }
      },
      "required": [
        "report"
      ]
    }
  },
  {
    "name": "test_gaps_analyze_test_coverage",
    "description": "Analyze test coverage in a codebase. TestCoverageReport with patterns, gaps, and statistics",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "test_gaps_detect_test_patterns",
    "description": "Detect test file naming patterns in a codebase. Scans the codebase for test files and identifies which naming patterns are in use. Also detects inline tests (e.g., Rust's #[cfg(test)]). List of detected test patterns, sorted by count (most common first)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "test_gaps_find_untested_files",
    "description": "Find source files without corresponding test files. List of source files missing tests",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        },
        "patterns": {
          "type": "string",
          "description": "Test patterns to use (auto-detected if None)"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "test_health_analyze_test_health",
    "description": "Analyze test health by extracting pytest markers. TestHealthReport with marker statistics and skip reasons",
    "inputSchema": {
      "type": "object",
      "properties": {
        "root": {
          "type": "string",
          "description": "Project root directory"
        }
      },
      "required": [
        "root"
      ]
    }
  },
  {
    "name": "dwim_analyze_intent",
    "description": "Analyze a natural language query to find the best matching tools. This is the main entry point for semantic routing. List of ToolMatch sorted by confidence (highest first)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": {
          "type": "string",
          "description": "Natural language description of what the user wants"
        },
        "available_tools": {
          "type": "string",
          "description": "Limit search to these tools (default: all)"
        }
      },
      "required": [
        "query"
      ]
    }
  },
  {
    "name": "dwim_expand_keywords",
    "description": "Expand keywords with word form variants for better matching.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "keywords": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "keywords"
      ]
    }
  },
  {
    "name": "dwim_get_embedding_matcher",
    "description": "Get the global embedding matcher instance (stub, embeddings removed).",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "dwim_get_router",
    "description": "Get the global tool router instance.",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "dwim_get_tool",
    "description": "Get a tool by name. ToolInfo or None if not found",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Tool name"
        }
      },
      "required": [
        "name"
      ]
    }
  },
  {
    "name": "dwim_get_tool_info",
    "description": "Get detailed information about a tool.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tool_name": {
          "type": "string"
        }
      },
      "required": [
        "tool_name"
      ]
    }
  },
  {
    "name": "dwim_list_tool_names",
    "description": "List all registered tool names.",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "dwim_list_tools",
    "description": "List all available tools with their descriptions.",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "dwim_normalize_parameters",
    "description": "Normalize parameter names to their canonical forms.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "params": {
          "type": "string"
        },
        "tool": {
          "type": "string"
        }
      },
      "required": [
        "params"
      ]
    }
  },
  {
    "name": "dwim_register_mcp_tool",
    "description": "Register an MCP tool into the DWIM registry. Extracts keywords from the tool name and description to enable natural language routing. The created ToolInfo",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "MCP tool name (e.g., \"read_file\", \"search\")"
        },
        "description": {
          "type": "string",
          "description": "Tool description from MCP"
        },
        "prefix": {
          "type": "string",
          "description": "Prefix for the registered tool name (default: \"mcp\")",
          "default": "mcp"
        },
        "input_schema": {
          "type": "string",
          "description": "Optional JSON schema for parameters"
        }
      },
      "required": [
        "name",
        "description"
      ]
    }
  },
  {
    "name": "dwim_register_tool",
    "description": "Register a tool for semantic routing.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tool": {
          "type": "string",
          "description": "ToolInfo describing the tool"
        }
      },
      "required": [
        "tool"
      ]
    }
  },
  {
    "name": "dwim_resolve_core_primitive",
    "description": "Resolve a name to one of the 3 core primitives. Uses exact match + basic typo correction (Levenshtein). Tuple of (canonical_name, confidence). Returns (None, 0.0) if no match found.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Tool name to resolve"
        }
      },
      "required": [
        "name"
      ]
    }
  },
  {
    "name": "dwim_resolve_parameter",
    "description": "Resolve a parameter name to its canonical form.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "param_name": {
          "type": "string"
        },
        "tool": {
          "type": "string"
        }
      },
      "required": [
        "param_name"
      ]
    }
  },
  {
    "name": "dwim_resolve_tool",
    "description": "Resolve a tool name to its canonical form. Handles: - Exact matches - Hyphen-to-underscore normalization - Semantic aliases - Fuzzy matching for typos",
    "inputSchema": {
      "type": "object",
      "properties": {
        "tool_name": {
          "type": "string"
        }
      },
      "required": [
        "tool_name"
      ]
    }
  },
  {
    "name": "dwim_string_similarity",
    "description": "Calculate similarity ratio between two strings.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "a": {
          "type": "string"
        },
        "b": {
          "type": "string"
        }
      },
      "required": [
        "a",
        "b"
      ]
    }
  },
  {
    "name": "dwim_suggest_tool",
    "description": "Suggest the best tool for a query, with confidence scoring. Returns the top match if confidence is above threshold, None otherwise.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": {
          "type": "string"
        }
      },
      "required": [
        "query"
      ]
    }
  },
  {
    "name": "dwim_suggest_tools",
    "description": "Suggest top-k tools for a query, regardless of threshold. Always returns up to top_k results, even if confidence is low. This is useful for showing alternatives when no confident match exists. List of ToolMatch sorted by confidence (highest first). Each match has a message indicating confidence level.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "query": {
          "type": "string",
          "description": "Natural language description of what the user wants"
        },
        "top_k": {
          "type": "integer",
          "description": "Maximum number of suggestions to return (default: 3)",
          "default": 3
        }
      },
      "required": [
        "query"
      ]
    }
  },
  {
    "name": "dwim_unregister_mcp_tools",
    "description": "Unregister all MCP tools with the given prefix. Number of tools unregistered",
    "inputSchema": {
      "type": "object",
      "properties": {
        "prefix": {
          "type": "string",
          "description": "Prefix used when registering (default: \"mcp\")",
          "default": "mcp"
        }
      }
    }
  },
  {
    "name": "dwim_unregister_tool",
    "description": "Unregister a tool. True if tool was removed, False if not found",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Tool name to remove"
        }
      },
      "required": [
        "name"
      ]
    }
  },
  {
    "name": "validators_create_cargo_validator",
    "description": "Create a Cargo/Rust validator with structured diagnostics. Uses --message-format=json for clean error parsing.",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "validators_create_eslint_validator",
    "description": "Create an ESLint validator with structured diagnostics. Uses --format json for structured output.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "default": "{path}"
        }
      }
    }
  },
  {
    "name": "validators_create_gcc_validator",
    "description": "Create a GCC/Clang validator with structured diagnostics.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "default": "{path}"
        }
      }
    }
  },
  {
    "name": "validators_create_python_validator_chain",
    "description": "Create a standard Python validation chain.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "include_tests": {
          "type": "boolean",
          "default": false
        }
      }
    }
  },
  {
    "name": "validators_create_rust_validator_chain",
    "description": "Create a Rust validator chain with structured diagnostics. ValidatorChain with cargo check",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "validators_create_typescript_validator",
    "description": "Create a TypeScript validator with structured diagnostics. Uses --pretty false for parseable output.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "default": "{path}"
        }
      }
    }
  },
  {
    "name": "validators_create_typescript_validator_chain",
    "description": "Create a TypeScript/JavaScript validator chain. ValidatorChain with tsc + eslint",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "validators_diagnostics_to_validation_result",
    "description": "Convert a DiagnosticSet to ValidationResult. This bridges the signal-only diagnostics module with the validation infrastructure, enabling structured error parsing for all validators. ValidationResult with converted issues",
    "inputSchema": {
      "type": "object",
      "properties": {
        "diagnostic_set": {
          "type": "string",
          "description": "DiagnosticSet from moss.diagnostics"
        },
        "success": {
          "type": "string",
          "description": "Override success status (defaults to no errors)"
        },
        "metadata": {
          "type": "string",
          "description": "Additional metadata to include"
        }
      },
      "required": [
        "diagnostic_set"
      ]
    }
  },
  {
    "name": "validators_get_all_validators",
    "description": "Get instances of all registered validators (with default args).",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "validators_get_validator",
    "description": "Get a validator instance by name. Validator instance ValueError: If validator not found",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Validator name"
        },
        "kwargs": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "kwargs"
      ]
    }
  },
  {
    "name": "validators_list_validators",
    "description": "List all registered validator names.",
    "inputSchema": {
      "type": "object",
      "properties": {}
    }
  },
  {
    "name": "validators_register_validator",
    "description": "Register a validator class.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Validator name (e.g., \"syntax\", \"ruff\")"
        },
        "validator_class": {
          "type": "string",
          "description": "Validator class (not instance)"
        }
      },
      "required": [
        "name",
        "validator_class"
      ]
    }
  }
]
