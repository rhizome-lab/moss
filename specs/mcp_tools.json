[
  {
    "description": "Get the full source code of a named symbol. Useful for getting complete enum definitions, class bodies, or function implementations when the skeleton isn't enough. Full source code of the symbol, or None if not found # Get full enum definition content = api.skeleton.expand(\"src/agent_loop.py\", \"StepType\") # Returns complete enum with all values",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the Python file",
          "type": "string"
        },
        "symbol_name": {
          "description": "Name of the symbol to expand (e.g., \"StepType\", \"my_function\")",
          "type": "string"
        }
      },
      "required": [
        "file_path",
        "symbol_name"
      ],
      "type": "object"
    },
    "name": "skeleton_expand"
  },
  {
    "description": "Extract code skeleton (functions, classes, methods). Example: moss skeleton src/main.py",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the Python file (relative to root or absolute)",
          "type": "string"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "skeleton_extract"
  },
  {
    "description": "Extract code skeleton (functions, classes, methods). Example: moss skeleton src/main.py",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the file",
          "type": "string"
        },
        "include_docstrings": {
          "default": true,
          "description": "Whether to include docstrings in output (Python only)",
          "type": "boolean"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "skeleton_format"
  },
  {
    "description": "Extract enum member names from an Enum class. List of enum member names, or None if not found values = api.skeleton.get_enum_values(\"src/agent_loop.py\", \"StepType\") # Returns: [\"TOOL\", \"LLM\", \"HYBRID\"]",
    "inputSchema": {
      "properties": {
        "enum_name": {
          "description": "Name of the Enum class",
          "type": "string"
        },
        "file_path": {
          "description": "Path to the Python file",
          "type": "string"
        }
      },
      "required": [
        "file_path",
        "enum_name"
      ],
      "type": "object"
    },
    "name": "skeleton_get_enum_values"
  },
  {
    "description": "Show git-aware file tree. Example: moss tree",
    "inputSchema": {
      "properties": {
        "compact": {
          "default": false,
          "description": "If True, use token-efficient format",
          "type": "boolean"
        },
        "path": {
          "description": "Directory to visualize (default: project root)",
          "type": "string"
        },
        "tracked_only": {
          "default": false,
          "description": "If True, only show git-tracked files",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "name": "tree_format"
  },
  {
    "description": "Show git-aware file tree. Example: moss tree",
    "inputSchema": {
      "properties": {
        "gitignore": {
          "default": true,
          "description": "If True, respect .gitignore when showing all files",
          "type": "boolean"
        },
        "path": {
          "description": "Directory to visualize (default: project root)",
          "type": "string"
        },
        "tracked_only": {
          "default": false,
          "description": "If True, only show git-tracked files",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "name": "tree_generate"
  },
  {
    "description": "Find anchors (functions, classes, methods) in code. Example: moss anchors src/api.py",
    "inputSchema": {
      "properties": {
        "anchor_type": {
          "default": "function",
          "description": "Type filter - \"function\", \"class\", \"variable\", \"method\", \"import\"",
          "type": "string"
        },
        "file_path": {
          "description": "Path to search in",
          "type": "string"
        },
        "name": {
          "description": "Name to search for (supports fuzzy matching)",
          "type": "string"
        }
      },
      "required": [
        "file_path",
        "name"
      ],
      "type": "object"
    },
    "name": "anchor_find"
  },
  {
    "description": "Find anchors (functions, classes, methods) in code. Example: moss anchors src/api.py",
    "inputSchema": {
      "properties": {
        "anchor_type": {
          "default": "function",
          "description": "Type filter",
          "type": "string"
        },
        "file_path": {
          "description": "Path to search in",
          "type": "string"
        },
        "name": {
          "description": "Name to search for",
          "type": "string"
        }
      },
      "required": [
        "file_path",
        "name"
      ],
      "type": "object"
    },
    "name": "anchor_resolve"
  },
  {
    "description": "Apply a patch to a file. PatchResult with success status and modified content",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the file to patch",
          "type": "string"
        },
        "patch": {
          "description": "Patch object describing the change",
          "type": "string"
        },
        "write": {
          "default": true,
          "description": "Whether to write changes to disk",
          "type": "boolean"
        }
      },
      "required": [
        "file_path",
        "patch"
      ],
      "type": "object"
    },
    "name": "patch_apply"
  },
  {
    "description": "Apply a patch with automatic text fallback. First tries AST-aware patching, falls back to text-based if that fails. PatchResult with success status and modified content",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the file to patch",
          "type": "string"
        },
        "patch": {
          "description": "Patch object describing the change",
          "type": "string"
        },
        "write": {
          "default": true,
          "description": "Whether to write changes to disk",
          "type": "boolean"
        }
      },
      "required": [
        "file_path",
        "patch"
      ],
      "type": "object"
    },
    "name": "patch_apply_with_fallback"
  },
  {
    "description": "Create a Patch object. Patch object ready for application",
    "inputSchema": {
      "properties": {
        "anchor_name": {
          "description": "Name of the anchor to target",
          "type": "string"
        },
        "content": {
          "description": "New content for the patch",
          "type": "string"
        },
        "kwargs": {
          "type": "string"
        },
        "patch_type": {
          "description": "Type of patch - \"insert_before\", \"insert_after\", \"replace\", \"delete\"",
          "type": "string"
        }
      },
      "required": [
        "patch_type",
        "anchor_name",
        "content",
        "kwargs"
      ],
      "type": "object"
    },
    "name": "patch_create"
  },
  {
    "description": "Extract dependencies (imports and exports). Example: moss deps src/api.py",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "dependencies_analyze"
  },
  {
    "description": "Build a dependency graph for the project. Dict mapping module names to their dependencies",
    "inputSchema": {
      "properties": {
        "internal_only": {
          "default": true,
          "description": "Only include internal module dependencies",
          "type": "boolean"
        },
        "path": {
          "description": "Directory to analyze (defaults to project root)",
          "type": "string"
        },
        "pattern": {
          "default": "**/*.py",
          "description": "Glob pattern for files to include",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "dependencies_build_graph"
  },
  {
    "description": "Extract dependencies (imports and exports). Example: moss deps src/api.py",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to analyze",
          "type": "string"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "dependencies_extract"
  },
  {
    "description": "Find files that import a given module. List of ReverseDependency objects",
    "inputSchema": {
      "properties": {
        "pattern": {
          "default": "**/*.py",
          "description": "Glob pattern for files to search",
          "type": "string"
        },
        "search_path": {
          "description": "Directory to search in (defaults to project root)",
          "type": "string"
        },
        "target_module": {
          "description": "Module name to search for",
          "type": "string"
        }
      },
      "required": [
        "target_module"
      ],
      "type": "object"
    },
    "name": "dependencies_find_reverse"
  },
  {
    "description": "Extract dependencies (imports and exports). Example: moss deps src/api.py",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to analyze",
          "type": "string"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "dependencies_format"
  },
  {
    "description": "Convert a dependency graph to DOT format. DOT-formatted string for visualization",
    "inputSchema": {
      "properties": {
        "graph": {
          "description": "Dependency graph from build_graph()",
          "type": "object"
        },
        "title": {
          "default": "Dependencies",
          "description": "Title for the graph",
          "type": "string"
        }
      },
      "required": [
        "graph"
      ],
      "type": "object"
    },
    "name": "dependencies_graph_to_dot"
  },
  {
    "description": "Build and display control flow graph. Example: moss cfg src/main.py",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the Python file",
          "type": "string"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "cfg_build"
  },
  {
    "description": "Create a standard Python validator chain. ValidatorChain configured for Python (syntax + ruff + pytest)",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "validation_create_chain"
  },
  {
    "description": "Validate a Python file with the default chain. ValidationResult with any issues found",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to validate",
          "type": "string"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "validation_validate"
  },
  {
    "description": "Abandon a checkpoint and delete its branch. Dict with 'success' boolean",
    "inputSchema": {
      "properties": {
        "name": {
          "description": "Checkpoint branch name to abort",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "git_abort_checkpoint"
  },
  {
    "description": "Create a commit on the specified shadow branch. CommitHandle referencing the new commit",
    "inputSchema": {
      "properties": {
        "branch": {
          "description": "ShadowBranch to commit on",
          "type": "string"
        },
        "message": {
          "description": "Commit message",
          "type": "string"
        }
      },
      "required": [
        "branch",
        "message"
      ],
      "type": "object"
    },
    "name": "git_commit"
  },
  {
    "description": "Create an isolated shadow branch for agent work. ShadowBranch for managing the branch",
    "inputSchema": {
      "properties": {
        "name": {
          "description": "Optional branch name (auto-generated if not provided)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "git_create_branch"
  },
  {
    "description": "Create a checkpoint with current changes. Checkpoints are shadow branches that capture current work state, allowing safe experimentation with easy rollback. Dict with 'branch' name and 'commit' SHA",
    "inputSchema": {
      "properties": {
        "message": {
          "description": "Optional commit message for initial checkpoint state",
          "type": "string"
        },
        "name": {
          "description": "Optional checkpoint name (auto-generated if not provided)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "git_create_checkpoint"
  },
  {
    "description": "Show changes in a checkpoint. Dict with 'diff' (full diff) and 'stat' (summary stats)",
    "inputSchema": {
      "properties": {
        "name": {
          "description": "Checkpoint branch name",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "git_diff_checkpoint"
  },
  {
    "description": "Initialize shadow git for the project. ShadowGit instance for managing branches",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "git_init"
  },
  {
    "description": "List active checkpoints. List of checkpoint info dicts with 'name' and 'type' keys",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "git_list_checkpoints"
  },
  {
    "description": "Merge checkpoint changes into base branch. Dict with 'commit' SHA of merge commit",
    "inputSchema": {
      "properties": {
        "message": {
          "description": "Optional merge commit message",
          "type": "string"
        },
        "name": {
          "description": "Checkpoint branch name to merge",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "git_merge_checkpoint"
  },
  {
    "description": "Compile context for the given files. CompiledContext with rendered views",
    "inputSchema": {
      "properties": {
        "file_paths": {
          "description": "Files to include in context",
          "type": "string"
        },
        "view_types": {
          "description": "View types to generate (default: skeleton, dependency)",
          "type": "string"
        }
      },
      "required": [
        "file_paths"
      ],
      "type": "object"
    },
    "name": "context_compile"
  },
  {
    "description": "Initialize the context host with default view providers. ContextHost instance",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "context_init"
  },
  {
    "description": "Analyze structural code quality. StructuralAnalysis with hotspots and metrics",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "health_analyze_structure"
  },
  {
    "description": "Analyze test coverage structure. TestAnalysis with module-test mappings",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "health_analyze_tests"
  },
  {
    "description": "Show project health and what needs attention. Example: moss health",
    "inputSchema": {
      "properties": {
        "focus": {
          "description": "Filter weak spots by category. Valid values: \"deps\" - dependency issues only \"tests\" - test coverage issues only \"complexity\" - complexity issues only \"api\" - API surface issues only None or \"all\" - show all categories",
          "type": "string"
        },
        "severity": {
          "default": "low",
          "description": "Minimum severity level to include. Valid values: \"low\" (default) - show all issues \"medium\" - show medium and high severity only \"high\" - show only high severity issues",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "health_check"
  },
  {
    "description": "Check documentation freshness against codebase. Example: moss check-docs",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "health_check_docs"
  },
  {
    "description": "Check TODOs against implementation status. Example: moss check-todos",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "health_check_todos"
  },
  {
    "description": "Generate hierarchical codebase summary. Example: moss summarize",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "health_summarize"
  },
  {
    "description": "List TODOs, optionally filtered by section. TodoListResult with items grouped by section",
    "inputSchema": {
      "properties": {
        "include_done": {
          "default": false,
          "description": "Include completed TODOs (default: False)",
          "type": "boolean"
        },
        "per_section_limit": {
          "default": 5,
          "description": "Max items to show per section (default: 5)",
          "type": "integer"
        },
        "section": {
          "description": "Filter to specific section (case-insensitive partial match)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "todo_list"
  },
  {
    "description": "Search TODOs by keyword. List of TodoSearchResult with matching items, sorted by relevance",
    "inputSchema": {
      "properties": {
        "include_done": {
          "default": false,
          "description": "Include completed TODOs (default: False)",
          "type": "boolean"
        },
        "query": {
          "description": "Search query (case-insensitive, matches text and section)",
          "type": "string"
        }
      },
      "required": [
        "query"
      ],
      "type": "object"
    },
    "name": "todo_search"
  },
  {
    "description": "List all TODO sections with counts. List of dicts with section name, pending count, and done count",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "todo_sections"
  },
  {
    "description": "Find the right Moss tool for any task using natural language. USE THIS FIRST when you don't know which tool to use! Describe what you want to do and get ranked suggestions. Examples: - \"summarize the codebase\" \u2192 health_summarize - \"show file structure\" \u2192 skeleton_format - \"find TODOs\" \u2192 health_check_todos - \"check code complexity\" \u2192 complexity_analyze List of ToolMatchResult sorted by confidence (highest first)",
    "inputSchema": {
      "properties": {
        "query": {
          "description": "Natural language description of what you want to do",
          "type": "string"
        },
        "top_k": {
          "default": 3,
          "description": "Maximum number of suggestions to return",
          "type": "integer"
        }
      },
      "required": [
        "query"
      ],
      "type": "object"
    },
    "name": "dwim_analyze_intent"
  },
  {
    "description": "Get detailed information about a specific tool. ToolInfoResult or None if tool not found",
    "inputSchema": {
      "properties": {
        "tool_name": {
          "description": "Tool name (can be alias or misspelled)",
          "type": "string"
        }
      },
      "required": [
        "tool_name"
      ],
      "type": "object"
    },
    "name": "dwim_get_tool_info"
  },
  {
    "description": "List all available tools with their metadata. ToolListResult with descriptions, keywords, etc.",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "dwim_list_tools"
  },
  {
    "description": "Resolve a tool name to its canonical form. Handles exact matches, semantic aliases, and fuzzy matching for typos. ToolMatchResult with canonical name and confidence",
    "inputSchema": {
      "properties": {
        "tool_name": {
          "description": "Tool name to resolve (may be misspelled or alias)",
          "type": "string"
        }
      },
      "required": [
        "tool_name"
      ],
      "type": "object"
    },
    "name": "dwim_resolve_tool"
  },
  {
    "description": "Analyze cyclomatic complexity of functions. Example: moss complexity src/",
    "inputSchema": {
      "properties": {
        "pattern": {
          "default": "**/*.py",
          "description": "Glob pattern for files to analyze (default: all Python files)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "complexity_analyze"
  },
  {
    "description": "Analyze cyclomatic complexity of functions. Example: moss complexity src/",
    "inputSchema": {
      "properties": {
        "threshold": {
          "default": 10,
          "description": "Complexity threshold (default: 10)",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "name": "complexity_get_high_risk"
  },
  {
    "description": "Detect structural clones in the codebase. CloneAnalysis with clone groups and statistics",
    "inputSchema": {
      "properties": {
        "level": {
          "default": 0,
          "description": "Elision level (0-3) controlling normalization: 0 = names only (exact structural clones) 1 = + literals (same structure, different constants) 2 = + calls (same pattern, different functions) 3 = control flow skeleton only",
          "type": "integer"
        },
        "min_lines": {
          "default": 3,
          "description": "Minimum function lines to consider (default: 3)",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "name": "clones_detect"
  },
  {
    "description": "Get clone groups with at least min_count members. List of clone group details",
    "inputSchema": {
      "properties": {
        "level": {
          "default": 0,
          "description": "Elision level (0-3)",
          "type": "integer"
        },
        "min_count": {
          "default": 2,
          "description": "Minimum clones per group (default: 2)",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "name": "clones_get_groups"
  },
  {
    "description": "Run security analysis. SecurityAnalysis with findings and summary",
    "inputSchema": {
      "properties": {
        "min_severity": {
          "default": "low",
          "description": "Minimum severity to report (\"low\", \"medium\", \"high\", \"critical\")",
          "type": "string"
        },
        "tools": {
          "description": "List of tools to use (None = all available)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "security_analyze"
  },
  {
    "description": "Get high and critical severity findings. List of high/critical security findings",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "security_get_high_severity"
  },
  {
    "description": "Check bidirectional references between code and docs. Example: moss check-refs",
    "inputSchema": {
      "properties": {
        "staleness_days": {
          "default": 30,
          "description": "Warn if target modified more than N days after source",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "name": "ref_check_check"
  },
  {
    "description": "Check only code-to-documentation references. List of broken code->doc references",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "ref_check_check_code_to_docs"
  },
  {
    "description": "Check only documentation-to-code references. List of broken doc->code references",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "ref_check_check_docs_to_code"
  },
  {
    "description": "Find frequently changed files in git history. Example: moss git-hotspots",
    "inputSchema": {
      "properties": {
        "days": {
          "default": 90,
          "description": "Number of days to analyze (default: 90)",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "name": "git_hotspots_analyze"
  },
  {
    "description": "Find frequently changed files in git history. Example: moss git-hotspots",
    "inputSchema": {
      "properties": {
        "days": {
          "default": 90,
          "description": "Number of days to analyze",
          "type": "integer"
        },
        "limit": {
          "default": 10,
          "description": "Maximum number of files to return",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "name": "git_hotspots_get_top_hotspots"
  },
  {
    "description": "Analyze external dependencies. Example: moss external-deps",
    "inputSchema": {
      "properties": {
        "check_licenses": {
          "default": false,
          "description": "If True, check license compatibility",
          "type": "boolean"
        },
        "check_vulns": {
          "default": false,
          "description": "If True, check for known vulnerabilities via OSV API",
          "type": "boolean"
        },
        "resolve": {
          "default": false,
          "description": "If True, resolve full transitive dependency tree",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "name": "external_deps_analyze"
  },
  {
    "description": "Analyze external dependencies. Example: moss external-deps",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "external_deps_check_security"
  },
  {
    "description": "Analyze external dependencies. Example: moss external-deps",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "external_deps_list_direct"
  },
  {
    "description": "Analyze codebase for architectural weaknesses. WeaknessAnalysis with detected weaknesses",
    "inputSchema": {
      "properties": {
        "categories": {
          "description": "Categories to check (None = all)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "weaknesses_analyze"
  },
  {
    "description": "Format weakness analysis as markdown. Markdown-formatted report",
    "inputSchema": {
      "properties": {
        "analysis": {
          "description": "WeaknessAnalysis to format",
          "type": "string"
        }
      },
      "required": [
        "analysis"
      ],
      "type": "object"
    },
    "name": "weaknesses_format"
  },
  {
    "description": "Clear the index. Dict with 'success' boolean",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "rag_clear"
  },
  {
    "description": "Index files for semantic search. Number of chunks indexed",
    "inputSchema": {
      "properties": {
        "force": {
          "default": false,
          "description": "Re-index even if content hasn't changed",
          "type": "boolean"
        },
        "path": {
          "description": "Directory to index (defaults to project root)",
          "type": "string"
        },
        "patterns": {
          "description": "Glob patterns to include (default: code and docs)",
          "type": "string"
        }
      },
      "type": "object"
    },
    "name": "rag_index"
  },
  {
    "description": "Search the index with natural language or code queries. List of SearchResult objects with file paths, scores, and snippets",
    "inputSchema": {
      "properties": {
        "kind": {
          "description": "Filter by symbol kind (e.g., \"function\", \"class\", \"module\")",
          "type": "string"
        },
        "limit": {
          "default": 10,
          "description": "Maximum results to return",
          "type": "integer"
        },
        "mode": {
          "default": "hybrid",
          "description": "Search mode - \"hybrid\", \"embedding\", or \"tfidf\"",
          "type": "string"
        },
        "query": {
          "description": "Natural language or code query",
          "type": "string"
        }
      },
      "required": [
        "query"
      ],
      "type": "object"
    },
    "name": "rag_search"
  },
  {
    "description": "Get index statistics. IndexStats with document count, files indexed, and backend info",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "rag_stats"
  },
  {
    "description": "Clear the web content cache. Number of cached items cleared",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "web_clear_cache"
  },
  {
    "description": "Extract clean content from HTML string. Dict with title, text, token_estimate, metadata",
    "inputSchema": {
      "properties": {
        "html": {
          "description": "Raw HTML content",
          "type": "string"
        },
        "url": {
          "default": "",
          "description": "Optional URL for metadata",
          "type": "string"
        }
      },
      "required": [
        "html"
      ],
      "type": "object"
    },
    "name": "web_extract_content"
  },
  {
    "description": "Fetch and extract content from URL. Dict with url, title, text, token_estimate, metadata",
    "inputSchema": {
      "properties": {
        "extract_main": {
          "default": true,
          "description": "Extract main content vs full page (default: True)",
          "type": "boolean"
        },
        "url": {
          "description": "URL to fetch",
          "type": "string"
        },
        "use_cache": {
          "default": true,
          "description": "Check cache first (default: True)",
          "type": "boolean"
        }
      },
      "required": [
        "url"
      ],
      "type": "object"
    },
    "name": "web_fetch"
  },
  {
    "description": "Search the web with token-efficient results. Dict with query, results list, and compact string representation",
    "inputSchema": {
      "properties": {
        "max_results": {
          "default": 5,
          "description": "Maximum number of results (default: 5)",
          "type": "integer"
        },
        "query": {
          "description": "Search query",
          "type": "string"
        }
      },
      "required": [
        "query"
      ],
      "type": "object"
    },
    "name": "web_search"
  },
  {
    "description": "Explain a symbol: show its definition, callers, and callees. Finds where a symbol is defined, what calls it, and what it calls. Useful for understanding code relationships and impact of changes. SymbolExplanation with callers and callees, or None if not found explanation = api.search.explain_symbol(\"process_request\") print(f\"Called by: {len(explanation.callers)} functions\") print(f\"Calls: {len(explanation.callees)} functions\")",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Optional file path to narrow down the search",
          "type": "string"
        },
        "name": {
          "description": "Symbol name to explain (function, class, or method)",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "search_explain_symbol"
  },
  {
    "description": "Find where a symbol is defined. Shortcut for find_symbols with exact matching. List of SymbolMatch objects for definitions",
    "inputSchema": {
      "properties": {
        "kind": {
          "description": "Filter by kind: function, class, method",
          "type": "string"
        },
        "name": {
          "description": "Exact symbol name to find",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "search_find_definitions"
  },
  {
    "description": "Find files matching a glob pattern. List of relative file paths matching the pattern",
    "inputSchema": {
      "properties": {
        "limit": {
          "default": 100,
          "description": "Maximum number of results to return",
          "type": "integer"
        },
        "path": {
          "description": "Directory to search in (defaults to project root)",
          "type": "string"
        },
        "pattern": {
          "description": "Glob pattern (e.g., \"**/*.py\", \"src/**/*.ts\")",
          "type": "string"
        }
      },
      "required": [
        "pattern"
      ],
      "type": "object"
    },
    "name": "search_find_files"
  },
  {
    "description": "Find files related to the given file through imports. Analyzes both: - Files that the given file imports from - Files that import the given file RelatedFilesResult with imports_from and imported_by lists",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the file to analyze",
          "type": "string"
        },
        "pattern": {
          "default": "**/*.py",
          "description": "Glob pattern for files to search for reverse dependencies",
          "type": "string"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "search_find_related_files"
  },
  {
    "description": "Find symbols by name across the codebase. Searches all Python files for functions, classes, methods, and variables matching the given name. List of SymbolMatch objects sorted by relevance",
    "inputSchema": {
      "properties": {
        "fuzzy": {
          "default": true,
          "description": "If True, match partial names; if False, exact match only",
          "type": "boolean"
        },
        "kind": {
          "description": "Filter by kind: function, class, method, variable",
          "type": "string"
        },
        "limit": {
          "default": 50,
          "description": "Maximum number of results to return",
          "type": "integer"
        },
        "name": {
          "description": "Symbol name to search for (supports partial matching)",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "search_find_symbols"
  },
  {
    "description": "Find usages of a symbol in the codebase. Searches for references to a symbol name, optionally excluding the definition sites. GrepResult with usage locations",
    "inputSchema": {
      "properties": {
        "exclude_definitions": {
          "default": true,
          "description": "If True, exclude definition lines",
          "type": "boolean"
        },
        "limit": {
          "default": 100,
          "description": "Maximum number of results to return",
          "type": "integer"
        },
        "name": {
          "description": "Symbol name to find usages of",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "search_find_usages"
  },
  {
    "description": "Search for text patterns in files. Uses regex pattern matching to find text in files. Similar to grep/ripgrep but integrated with Moss. GrepResult with matches and statistics",
    "inputSchema": {
      "properties": {
        "context_lines": {
          "default": 0,
          "description": "Number of context lines before/after match",
          "type": "integer"
        },
        "glob": {
          "description": "Glob pattern to filter files (e.g., \"*.py\", \"**/*.ts\")",
          "type": "string"
        },
        "ignore_case": {
          "default": false,
          "description": "If True, perform case-insensitive matching",
          "type": "boolean"
        },
        "limit": {
          "default": 100,
          "description": "Maximum number of matches to return",
          "type": "integer"
        },
        "path": {
          "description": "Directory to search in (defaults to project root)",
          "type": "string"
        },
        "pattern": {
          "description": "Regex pattern to search for",
          "type": "string"
        }
      },
      "required": [
        "pattern"
      ],
      "type": "object"
    },
    "name": "search_grep"
  },
  {
    "description": "Resolve a file name with DWIM (Do What I Mean). Handles typos, missing extensions, and partial paths. FileMatch with resolved path and confidence",
    "inputSchema": {
      "properties": {
        "extensions": {
          "description": "Extensions to try if name has none (default: .py, .ts, .js, .tsx, .jsx)",
          "type": "string"
        },
        "name": {
          "description": "File name, partial path, or module name to resolve",
          "type": "string"
        }
      },
      "required": [
        "name"
      ],
      "type": "object"
    },
    "name": "search_resolve_file"
  },
  {
    "description": "Summarize what a Python module does. Extracts: - Module docstring - Public classes with their docstrings - Public functions with their docstrings - Public constants - Basic metrics (line count, import count) ModuleSummary with module information",
    "inputSchema": {
      "properties": {
        "file_path": {
          "description": "Path to the Python file",
          "type": "string"
        }
      },
      "required": [
        "file_path"
      ],
      "type": "object"
    },
    "name": "search_summarize_module"
  },
  {
    "description": "Analyze codebase guessability. Evaluates: - Name-content alignment: Do module names reflect their contents? - Predictability: Are similar things in similar places? - Pattern consistency: Are conventions followed? GuessabilityReport with scores and recommendations",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "guessability_analyze"
  },
  {
    "description": "Get guessability improvement recommendations. List of actionable recommendations",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "guessability_recommendations"
  },
  {
    "description": "Get overall guessability score. GuessabilityScore with 'score' (0.0-1.0) and 'grade' (A-F)",
    "inputSchema": {
      "properties": {},
      "type": "object"
    },
    "name": "guessability_score"
  }
]
