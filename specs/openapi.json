{
  "info": {
    "description": "Headless agent orchestration layer",
    "title": "Moss API",
    "version": "0.1.0"
  },
  "openapi": "3.0.3",
  "paths": {
    "/anchor/find": {
      "get": {
        "description": "Find anchors matching a name in a file. List of AnchorMatch objects with locations and confidence scores",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_type": {
                    "default": "function",
                    "description": "Type filter - \"function\", \"class\", \"variable\", \"method\", \"import\"",
                    "type": "string"
                  },
                  "file_path": {
                    "description": "Path to search in",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name to search for (supports fuzzy matching)",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find anchors matching a name in a file",
        "tags": [
          "anchor"
        ]
      }
    },
    "/anchor/resolve": {
      "get": {
        "description": "Resolve a single anchor (raises if ambiguous or not found). Single best AnchorMatch AnchorNotFoundError: If no match found AmbiguousAnchorError: If multiple matches with equal confidence",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_type": {
                    "default": "function",
                    "description": "Type filter",
                    "type": "string"
                  },
                  "file_path": {
                    "description": "Path to search in",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name to search for",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Resolve a single anchor (raises if ambiguous or not found)",
        "tags": [
          "anchor"
        ]
      }
    },
    "/cfg/build": {
      "post": {
        "description": "Build CFGs for all functions in a file. List of ControlFlowGraph objects for each function",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Build CFGs for all functions in a file",
        "tags": [
          "cfg"
        ]
      }
    },
    "/complexity/analyze": {
      "get": {
        "description": "Analyze cyclomatic complexity of all Python files. ComplexityReport with complexity metrics for all functions",
        "parameters": [
          {
            "description": "Glob pattern for files to analyze (default: all Python files)",
            "in": "query",
            "name": "pattern",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze cyclomatic complexity of all Python files",
        "tags": [
          "complexity"
        ]
      }
    },
    "/complexity/get-high-risk": {
      "get": {
        "description": "Get functions exceeding a complexity threshold. List of function details for high-complexity functions",
        "parameters": [
          {
            "description": "Complexity threshold (default: 10)",
            "in": "query",
            "name": "threshold",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get functions exceeding a complexity threshold",
        "tags": [
          "complexity"
        ]
      }
    },
    "/context/compile": {
      "post": {
        "description": "Compile context for the given files. CompiledContext with rendered views",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_paths": {
                    "description": "Files to include in context",
                    "type": "array"
                  },
                  "view_types": {
                    "description": "View types to generate (default: skeleton, dependency)",
                    "type": "array"
                  }
                },
                "required": [
                  "file_paths"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Compile context for the given files",
        "tags": [
          "context"
        ]
      }
    },
    "/context/init": {
      "post": {
        "description": "Initialize the context host with default view providers. ContextHost instance",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Initialize the context host with default view providers",
        "tags": [
          "context"
        ]
      }
    },
    "/dependencies/analyze": {
      "get": {
        "description": "Run full dependency analysis on the project. DependencyAnalysis with circular deps, god modules, orphans, etc.",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run full dependency analysis on the project",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dependencies/extract": {
      "post": {
        "description": "Extract imports and exports from a file. DependencyInfo with imports and exports",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to analyze",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract imports and exports from a file",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dependencies/format": {
      "post": {
        "description": "Extract and format dependencies as readable text. Formatted string with imports and exports",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to analyze",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract and format dependencies as readable text",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dwim/analyze-intent": {
      "get": {
        "description": "Find the right Moss tool for any task using natural language. USE THIS FIRST when you don't know which tool to use! Describe what you want to do and get ranked suggestions. Examples: - \"summarize the codebase\" \u2192 health_summarize - \"show file structure\" \u2192 skeleton_format - \"find TODOs\" \u2192 health_check_todos - \"check code complexity\" \u2192 complexity_analyze List of ToolMatchResult sorted by confidence (highest first)",
        "parameters": [
          {
            "description": "Natural language description of what you want to do",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of suggestions to return",
            "in": "query",
            "name": "top_k",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find the right Moss tool for any task using natural language",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/get-tool-info": {
      "get": {
        "description": "Get detailed information about a specific tool. ToolInfoResult or None if tool not found",
        "parameters": [
          {
            "description": "Tool name (can be alias or misspelled)",
            "in": "query",
            "name": "tool_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get detailed information about a specific tool",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/list-tools": {
      "get": {
        "description": "List all available tools with their metadata. ToolListResult with descriptions, keywords, etc.",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List all available tools with their metadata",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/resolve-tool": {
      "get": {
        "description": "Resolve a tool name to its canonical form. Handles exact matches, semantic aliases, and fuzzy matching for typos. ToolMatchResult with canonical name and confidence",
        "parameters": [
          {
            "description": "Tool name to resolve (may be misspelled or alias)",
            "in": "query",
            "name": "tool_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Resolve a tool name to its canonical form",
        "tags": [
          "dwim"
        ]
      }
    },
    "/external_deps/analyze": {
      "get": {
        "description": "Analyze project dependencies. DependencyAnalysisResult with dependency information",
        "parameters": [
          {
            "description": "If True, resolve full transitive dependency tree",
            "in": "query",
            "name": "resolve",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If True, check for known vulnerabilities via OSV API",
            "in": "query",
            "name": "check_vulns",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If True, check license compatibility",
            "in": "query",
            "name": "check_licenses",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze project dependencies",
        "tags": [
          "external_deps"
        ]
      }
    },
    "/external_deps/check-security": {
      "get": {
        "description": "Check for security vulnerabilities. List of vulnerability details",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check for security vulnerabilities",
        "tags": [
          "external_deps"
        ]
      }
    },
    "/external_deps/list-direct": {
      "get": {
        "description": "List direct dependencies. List of direct dependency details",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List direct dependencies",
        "tags": [
          "external_deps"
        ]
      }
    },
    "/git/abort-checkpoint": {
      "post": {
        "description": "Abandon a checkpoint and delete its branch. Dict with 'success' boolean",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Checkpoint branch name to abort",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Abandon a checkpoint and delete its branch",
        "tags": [
          "git"
        ]
      }
    },
    "/git/commit": {
      "post": {
        "description": "Create a commit on the specified shadow branch. CommitHandle referencing the new commit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "branch": {
                    "description": "ShadowBranch to commit on",
                    "type": "string"
                  },
                  "message": {
                    "description": "Commit message",
                    "type": "string"
                  }
                },
                "required": [
                  "branch",
                  "message"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a commit on the specified shadow branch",
        "tags": [
          "git"
        ]
      }
    },
    "/git/create-branch": {
      "post": {
        "description": "Create an isolated shadow branch for agent work. ShadowBranch for managing the branch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Optional branch name (auto-generated if not provided)",
                    "type": "string"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create an isolated shadow branch for agent work",
        "tags": [
          "git"
        ]
      }
    },
    "/git/create-checkpoint": {
      "post": {
        "description": "Create a checkpoint with current changes. Checkpoints are shadow branches that capture current work state, allowing safe experimentation with easy rollback. Dict with 'branch' name and 'commit' SHA",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "message": {
                    "description": "Optional commit message for initial checkpoint state",
                    "type": "string"
                  },
                  "name": {
                    "description": "Optional checkpoint name (auto-generated if not provided)",
                    "type": "string"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a checkpoint with current changes",
        "tags": [
          "git"
        ]
      }
    },
    "/git/diff-checkpoint": {
      "post": {
        "description": "Show changes in a checkpoint. Dict with 'diff' (full diff) and 'stat' (summary stats)",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Checkpoint branch name",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Show changes in a checkpoint",
        "tags": [
          "git"
        ]
      }
    },
    "/git/init": {
      "post": {
        "description": "Initialize shadow git for the project. ShadowGit instance for managing branches",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Initialize shadow git for the project",
        "tags": [
          "git"
        ]
      }
    },
    "/git/list-checkpoints": {
      "get": {
        "description": "List active checkpoints. List of checkpoint info dicts with 'name' and 'type' keys",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List active checkpoints",
        "tags": [
          "git"
        ]
      }
    },
    "/git/merge-checkpoint": {
      "post": {
        "description": "Merge checkpoint changes into base branch. Dict with 'commit' SHA of merge commit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "message": {
                    "description": "Optional merge commit message",
                    "type": "string"
                  },
                  "name": {
                    "description": "Checkpoint branch name to merge",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Merge checkpoint changes into base branch",
        "tags": [
          "git"
        ]
      }
    },
    "/git_hotspots/analyze": {
      "get": {
        "description": "Analyze git history for hot spots. GitHotspotAnalysis with frequently changed files",
        "parameters": [
          {
            "description": "Number of days to analyze (default: 90)",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze git history for hot spots",
        "tags": [
          "git_hotspots"
        ]
      }
    },
    "/git_hotspots/get-top-hotspots": {
      "get": {
        "description": "Get the top N most frequently changed files. List of hotspot details for most frequently changed files",
        "parameters": [
          {
            "description": "Number of days to analyze",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of files to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get the top N most frequently changed files",
        "tags": [
          "git_hotspots"
        ]
      }
    },
    "/health/analyze-structure": {
      "get": {
        "description": "Analyze structural code quality. StructuralAnalysis with hotspots and metrics",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze structural code quality",
        "tags": [
          "health"
        ]
      }
    },
    "/health/analyze-tests": {
      "get": {
        "description": "Analyze test coverage structure. TestAnalysis with module-test mappings",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze test coverage structure",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check": {
      "get": {
        "description": "Run full health analysis on the project. ProjectStatus with health score, grade, and detailed metrics",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run full health analysis on the project",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check-docs": {
      "get": {
        "description": "Check documentation health. DocCheckResult with coverage and issues",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check documentation health",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check-todos": {
      "get": {
        "description": "Check TODO tracking health. TodoCheckResult with tracked and orphaned TODOs",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check TODO tracking health",
        "tags": [
          "health"
        ]
      }
    },
    "/health/summarize": {
      "get": {
        "description": "Generate a project summary. ProjectSummary with module information",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Generate a project summary",
        "tags": [
          "health"
        ]
      }
    },
    "/patch/apply": {
      "post": {
        "description": "Apply a patch to a file. PatchResult with success status and modified content",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file to patch",
                    "type": "string"
                  },
                  "patch": {
                    "description": "Patch object describing the change",
                    "type": "string"
                  },
                  "write": {
                    "default": true,
                    "description": "Whether to write changes to disk",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path",
                  "patch"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Apply a patch to a file",
        "tags": [
          "patch"
        ]
      }
    },
    "/patch/apply-with-fallback": {
      "post": {
        "description": "Apply a patch with automatic text fallback. First tries AST-aware patching, falls back to text-based if that fails. PatchResult with success status and modified content",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file to patch",
                    "type": "string"
                  },
                  "patch": {
                    "description": "Patch object describing the change",
                    "type": "string"
                  },
                  "write": {
                    "default": true,
                    "description": "Whether to write changes to disk",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path",
                  "patch"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Apply a patch with automatic text fallback",
        "tags": [
          "patch"
        ]
      }
    },
    "/patch/create": {
      "post": {
        "description": "Create a Patch object. Patch object ready for application",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_name": {
                    "description": "Name of the anchor to target",
                    "type": "string"
                  },
                  "content": {
                    "description": "New content for the patch",
                    "type": "string"
                  },
                  "kwargs": {
                    "description": "",
                    "type": "string"
                  },
                  "patch_type": {
                    "description": "Type of patch - \"insert_before\", \"insert_after\", \"replace\", \"delete\"",
                    "type": "string"
                  }
                },
                "required": [
                  "patch_type",
                  "anchor_name",
                  "content",
                  "kwargs"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a Patch object",
        "tags": [
          "patch"
        ]
      }
    },
    "/rag/clear": {
      "post": {
        "description": "Clear the index. Dict with 'success' boolean",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Clear the index",
        "tags": [
          "rag"
        ]
      }
    },
    "/rag/index": {
      "post": {
        "description": "Index files for semantic search. Number of chunks indexed",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "force": {
                    "default": false,
                    "description": "Re-index even if content hasn't changed",
                    "type": "boolean"
                  },
                  "path": {
                    "description": "Directory to index (defaults to project root)",
                    "type": "string"
                  },
                  "patterns": {
                    "description": "Glob patterns to include (default: code and docs)",
                    "type": "array"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Index files for semantic search",
        "tags": [
          "rag"
        ]
      }
    },
    "/rag/search": {
      "post": {
        "description": "Search the index with natural language or code queries. List of SearchResult objects with file paths, scores, and snippets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "kind": {
                    "description": "Filter by symbol kind (e.g., \"function\", \"class\", \"module\")",
                    "type": "string"
                  },
                  "limit": {
                    "default": 10,
                    "description": "Maximum results to return",
                    "type": "integer"
                  },
                  "mode": {
                    "default": "hybrid",
                    "description": "Search mode - \"hybrid\", \"embedding\", or \"tfidf\"",
                    "type": "string"
                  },
                  "query": {
                    "description": "Natural language or code query",
                    "type": "string"
                  }
                },
                "required": [
                  "query"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Search the index with natural language or code queries",
        "tags": [
          "rag"
        ]
      }
    },
    "/rag/stats": {
      "post": {
        "description": "Get index statistics. IndexStats with document count, files indexed, and backend info",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get index statistics",
        "tags": [
          "rag"
        ]
      }
    },
    "/ref_check/check": {
      "get": {
        "description": "Run bidirectional reference check. RefCheckResult with valid, broken, and stale references",
        "parameters": [
          {
            "description": "Warn if target modified more than N days after source",
            "in": "query",
            "name": "staleness_days",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run bidirectional reference check",
        "tags": [
          "ref_check"
        ]
      }
    },
    "/ref_check/check-code-to-docs": {
      "get": {
        "description": "Check only code-to-documentation references. List of broken code->doc references",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check only code-to-documentation references",
        "tags": [
          "ref_check"
        ]
      }
    },
    "/ref_check/check-docs-to-code": {
      "get": {
        "description": "Check only documentation-to-code references. List of broken doc->code references",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check only documentation-to-code references",
        "tags": [
          "ref_check"
        ]
      }
    },
    "/skeleton/extract": {
      "post": {
        "description": "Extract skeleton from a Python file. List of Symbol objects representing the code structure Note: For non-Python files, use format() which routes through the plugin system.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file (relative to root or absolute)",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract skeleton from a Python file",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/skeleton/format": {
      "post": {
        "description": "Extract and format skeleton as readable text. Uses the plugin registry to support multiple file types (Python, Markdown, etc.). Formatted string representation of the skeleton",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file",
                    "type": "string"
                  },
                  "include_docstrings": {
                    "default": true,
                    "description": "Whether to include docstrings in output (Python only)",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract and format skeleton as readable text",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/todo/list": {
      "get": {
        "description": "List TODOs, optionally filtered by section. List of TodoSearchResult with matching items",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "include_done": {
                    "default": false,
                    "description": "Include completed TODOs (default: False)",
                    "type": "boolean"
                  },
                  "section": {
                    "description": "Filter to specific section (case-insensitive partial match)",
                    "type": "string"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List TODOs, optionally filtered by section",
        "tags": [
          "todo"
        ]
      }
    },
    "/todo/search": {
      "post": {
        "description": "Search TODOs by keyword. List of TodoSearchResult with matching items, sorted by relevance",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "include_done": {
                    "default": false,
                    "description": "Include completed TODOs (default: False)",
                    "type": "boolean"
                  },
                  "query": {
                    "description": "Search query (case-insensitive, matches text and section)",
                    "type": "string"
                  }
                },
                "required": [
                  "query"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Search TODOs by keyword",
        "tags": [
          "todo"
        ]
      }
    },
    "/todo/sections": {
      "post": {
        "description": "List all TODO sections with counts. List of dicts with section name, pending count, and done count",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List all TODO sections with counts",
        "tags": [
          "todo"
        ]
      }
    },
    "/tree/format": {
      "post": {
        "description": "Generate and format tree as readable text. Formatted tree visualization",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "compact": {
                    "default": false,
                    "description": "If True, use token-efficient format",
                    "type": "boolean"
                  },
                  "path": {
                    "description": "Directory to visualize (default: project root)",
                    "type": "string"
                  },
                  "tracked_only": {
                    "default": false,
                    "description": "If True, only show git-tracked files",
                    "type": "boolean"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Generate and format tree as readable text",
        "tags": [
          "tree"
        ]
      }
    },
    "/tree/generate": {
      "post": {
        "description": "Generate a tree visualization of a directory. TreeResult with tree visualization and file counts",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "gitignore": {
                    "default": true,
                    "description": "If True, respect .gitignore when showing all files",
                    "type": "boolean"
                  },
                  "path": {
                    "description": "Directory to visualize (default: project root)",
                    "type": "string"
                  },
                  "tracked_only": {
                    "default": false,
                    "description": "If True, only show git-tracked files",
                    "type": "boolean"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Generate a tree visualization of a directory",
        "tags": [
          "tree"
        ]
      }
    },
    "/validation/create-chain": {
      "post": {
        "description": "Create a standard Python validator chain. ValidatorChain configured for Python (syntax + ruff + pytest)",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a standard Python validator chain",
        "tags": [
          "validation"
        ]
      }
    },
    "/validation/validate": {
      "post": {
        "description": "Validate a Python file with the default chain. ValidationResult with any issues found",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to validate",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Validate a Python file with the default chain",
        "tags": [
          "validation"
        ]
      }
    }
  },
  "tags": [
    {
      "description": "API for code skeleton extraction. Extracts structural summaries of code (classes, functions, signatures) without implementation details. Supports multiple languages via plugin system.",
      "name": "skeleton"
    },
    {
      "description": "API for git-aware file tree visualization. Shows project structure with awareness of git tracking status.",
      "name": "tree"
    },
    {
      "description": "API for finding code locations using fuzzy anchors. Anchors identify code elements (functions, classes, variables) by name and type, with fuzzy matching support.",
      "name": "anchor"
    },
    {
      "description": "API for applying code patches. Supports AST-aware patching with automatic fallback to text-based patching when AST parsing fails.",
      "name": "patch"
    },
    {
      "description": "API for dependency analysis. Analyzes import/export relationships, detects circular dependencies, and provides coupling metrics.",
      "name": "dependencies"
    },
    {
      "description": "API for control flow graph analysis. Builds control flow graphs showing execution paths through functions.",
      "name": "cfg"
    },
    {
      "description": "API for code validation. Runs validators (syntax, linting, tests) and reports issues.",
      "name": "validation"
    },
    {
      "description": "API for shadow git operations. Provides atomic commit/rollback operations for safe code modifications.",
      "name": "git"
    },
    {
      "description": "API for context compilation. Compiles code views (skeletons, CFGs, dependencies) into structured context for AI consumption.",
      "name": "context"
    },
    {
      "description": "API for project health analysis. Provides comprehensive project health metrics and reports.",
      "name": "health"
    },
    {
      "description": "API for TODO management and search. Search and browse TODOs from TODO.md. Useful for finding relevant work items and understanding project priorities.",
      "name": "todo"
    },
    {
      "description": "START HERE - Tool discovery and routing for Moss. Don't know which Moss tool to use? Ask DWIM! This API helps you find the right tool for any task using natural language queries. Features: - Natural language queries: describe what you want, get tool suggestions - Semantic aliases: map conceptual names to canonical tools - Fuzzy matching: handle typos and variations - Confidence scoring: know when to auto-correct vs suggest",
      "name": "dwim"
    },
    {
      "description": "API for cyclomatic complexity analysis. Calculates McCabe cyclomatic complexity for Python functions, helping identify code that may be difficult to test or maintain.",
      "name": "complexity"
    },
    {
      "description": "API for bidirectional reference checking. Validates that code files reference their documentation and documentation references implementation files. Detects stale references where targets have been modified after sources.",
      "name": "ref_check"
    },
    {
      "description": "API for git hotspot analysis. Identifies frequently changed files in the git repository. High churn areas may indicate code that needs refactoring.",
      "name": "git_hotspots"
    },
    {
      "description": "API for external dependency analysis. Analyzes PyPI/npm dependencies including transitive dependencies, security vulnerabilities, and license compatibility.",
      "name": "external_deps"
    },
    {
      "description": "API for RAG (Retrieval-Augmented Generation) semantic search. Provides semantic code search capabilities using vector embeddings. Index your codebase once, then search with natural language queries.",
      "name": "rag"
    }
  ]
}
