{
  "info": {
    "description": "Headless agent orchestration layer",
    "title": "Moss API",
    "version": "0.1.0"
  },
  "openapi": "3.0.3",
  "paths": {
    "/anchor/find": {
      "get": {
        "description": "Find anchors matching a name in a file. List of AnchorMatch objects with locations and confidence scores",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_type": {
                    "default": "function",
                    "description": "Type filter - \"function\", \"class\", \"variable\", \"method\", \"import\"",
                    "type": "string"
                  },
                  "file_path": {
                    "description": "Path to search in",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name to search for (supports fuzzy matching)",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find anchors matching a name in a file",
        "tags": [
          "anchor"
        ]
      }
    },
    "/anchor/resolve": {
      "get": {
        "description": "Resolve a single anchor (raises if ambiguous or not found). Single best AnchorMatch AnchorNotFoundError: If no match found AmbiguousAnchorError: If multiple matches with equal confidence",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_type": {
                    "default": "function",
                    "description": "Type filter",
                    "type": "string"
                  },
                  "file_path": {
                    "description": "Path to search in",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name to search for",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Resolve a single anchor (raises if ambiguous or not found)",
        "tags": [
          "anchor"
        ]
      }
    },
    "/cfg/build": {
      "post": {
        "description": "Build CFGs for all functions in a file. List of ControlFlowGraph objects for each function",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Build CFGs for all functions in a file",
        "tags": [
          "cfg"
        ]
      }
    },
    "/clones/detect": {
      "post": {
        "description": "Detect structural clones in the codebase. CloneAnalysis with clone groups and statistics",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "level": {
                    "default": 0,
                    "description": "Elision level (0-3) controlling normalization: 0 = names only (exact structural clones) 1 = + literals (same structure, different constants) 2 = + calls (same pattern, different functions) 3 = control flow skeleton only",
                    "type": "integer"
                  },
                  "min_lines": {
                    "default": 3,
                    "description": "Minimum function lines to consider (default: 3)",
                    "type": "integer"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Detect structural clones in the codebase",
        "tags": [
          "clones"
        ]
      }
    },
    "/clones/get-groups": {
      "get": {
        "description": "Get clone groups with at least min_count members. List of clone group details",
        "parameters": [
          {
            "description": "Elision level (0-3)",
            "in": "query",
            "name": "level",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Minimum clones per group (default: 2)",
            "in": "query",
            "name": "min_count",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get clone groups with at least min_count members",
        "tags": [
          "clones"
        ]
      }
    },
    "/complexity/analyze": {
      "get": {
        "description": "Analyze cyclomatic complexity of all Python files. ComplexityReport with complexity metrics for all functions",
        "parameters": [
          {
            "description": "Glob pattern for files to analyze (default: all Python files)",
            "in": "query",
            "name": "pattern",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze cyclomatic complexity of all Python files",
        "tags": [
          "complexity"
        ]
      }
    },
    "/complexity/get-high-risk": {
      "get": {
        "description": "Get functions exceeding a complexity threshold. List of function details for high-complexity functions",
        "parameters": [
          {
            "description": "Complexity threshold (default: 10)",
            "in": "query",
            "name": "threshold",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get functions exceeding a complexity threshold",
        "tags": [
          "complexity"
        ]
      }
    },
    "/context/compile": {
      "post": {
        "description": "Compile context for the given files. CompiledContext with rendered views",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_paths": {
                    "description": "Files to include in context",
                    "type": "array"
                  },
                  "view_types": {
                    "description": "View types to generate (default: skeleton, dependency)",
                    "type": "array"
                  }
                },
                "required": [
                  "file_paths"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Compile context for the given files",
        "tags": [
          "context"
        ]
      }
    },
    "/context/init": {
      "post": {
        "description": "Initialize the context host with default view providers. ContextHost instance",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Initialize the context host with default view providers",
        "tags": [
          "context"
        ]
      }
    },
    "/dependencies/analyze": {
      "get": {
        "description": "Run full dependency analysis on the project. DependencyAnalysis with circular deps, god modules, orphans, etc.",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run full dependency analysis on the project",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dependencies/extract": {
      "post": {
        "description": "Extract imports and exports from a file. DependencyInfo with imports and exports",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to analyze",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract imports and exports from a file",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dependencies/format": {
      "post": {
        "description": "Extract and format dependencies as readable text. Formatted string with imports and exports",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to analyze",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract and format dependencies as readable text",
        "tags": [
          "dependencies"
        ]
      }
    },
    "/dwim/analyze-intent": {
      "get": {
        "description": "Find the right Moss tool for any task using natural language. USE THIS FIRST when you don't know which tool to use! Describe what you want to do and get ranked suggestions. Examples: - \"summarize the codebase\" \u2192 health_summarize - \"show file structure\" \u2192 skeleton_format - \"find TODOs\" \u2192 health_check_todos - \"check code complexity\" \u2192 complexity_analyze List of ToolMatchResult sorted by confidence (highest first)",
        "parameters": [
          {
            "description": "Natural language description of what you want to do",
            "in": "query",
            "name": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of suggestions to return",
            "in": "query",
            "name": "top_k",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find the right Moss tool for any task using natural language",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/get-tool-info": {
      "get": {
        "description": "Get detailed information about a specific tool. ToolInfoResult or None if tool not found",
        "parameters": [
          {
            "description": "Tool name (can be alias or misspelled)",
            "in": "query",
            "name": "tool_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get detailed information about a specific tool",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/list-tools": {
      "get": {
        "description": "List all available tools with their metadata. ToolListResult with descriptions, keywords, etc.",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List all available tools with their metadata",
        "tags": [
          "dwim"
        ]
      }
    },
    "/dwim/resolve-tool": {
      "get": {
        "description": "Resolve a tool name to its canonical form. Handles exact matches, semantic aliases, and fuzzy matching for typos. ToolMatchResult with canonical name and confidence",
        "parameters": [
          {
            "description": "Tool name to resolve (may be misspelled or alias)",
            "in": "query",
            "name": "tool_name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Resolve a tool name to its canonical form",
        "tags": [
          "dwim"
        ]
      }
    },
    "/external_deps/analyze": {
      "get": {
        "description": "Analyze project dependencies. DependencyAnalysisResult with dependency information",
        "parameters": [
          {
            "description": "If True, resolve full transitive dependency tree",
            "in": "query",
            "name": "resolve",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If True, check for known vulnerabilities via OSV API",
            "in": "query",
            "name": "check_vulns",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If True, check license compatibility",
            "in": "query",
            "name": "check_licenses",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze project dependencies",
        "tags": [
          "external_deps"
        ]
      }
    },
    "/external_deps/check-security": {
      "get": {
        "description": "Check for security vulnerabilities. List of vulnerability details",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check for security vulnerabilities",
        "tags": [
          "external_deps"
        ]
      }
    },
    "/external_deps/list-direct": {
      "get": {
        "description": "List direct dependencies. List of direct dependency details",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List direct dependencies",
        "tags": [
          "external_deps"
        ]
      }
    },
    "/git/abort-checkpoint": {
      "post": {
        "description": "Abandon a checkpoint and delete its branch. Dict with 'success' boolean",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Checkpoint branch name to abort",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Abandon a checkpoint and delete its branch",
        "tags": [
          "git"
        ]
      }
    },
    "/git/commit": {
      "post": {
        "description": "Create a commit on the specified shadow branch. CommitHandle referencing the new commit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "branch": {
                    "description": "ShadowBranch to commit on",
                    "type": "string"
                  },
                  "message": {
                    "description": "Commit message",
                    "type": "string"
                  }
                },
                "required": [
                  "branch",
                  "message"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a commit on the specified shadow branch",
        "tags": [
          "git"
        ]
      }
    },
    "/git/create-branch": {
      "post": {
        "description": "Create an isolated shadow branch for agent work. ShadowBranch for managing the branch",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Optional branch name (auto-generated if not provided)",
                    "type": "string"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create an isolated shadow branch for agent work",
        "tags": [
          "git"
        ]
      }
    },
    "/git/create-checkpoint": {
      "post": {
        "description": "Create a checkpoint with current changes. Checkpoints are shadow branches that capture current work state, allowing safe experimentation with easy rollback. Dict with 'branch' name and 'commit' SHA",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "message": {
                    "description": "Optional commit message for initial checkpoint state",
                    "type": "string"
                  },
                  "name": {
                    "description": "Optional checkpoint name (auto-generated if not provided)",
                    "type": "string"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a checkpoint with current changes",
        "tags": [
          "git"
        ]
      }
    },
    "/git/diff-checkpoint": {
      "post": {
        "description": "Show changes in a checkpoint. Dict with 'diff' (full diff) and 'stat' (summary stats)",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "name": {
                    "description": "Checkpoint branch name",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Show changes in a checkpoint",
        "tags": [
          "git"
        ]
      }
    },
    "/git/init": {
      "post": {
        "description": "Initialize shadow git for the project. ShadowGit instance for managing branches",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Initialize shadow git for the project",
        "tags": [
          "git"
        ]
      }
    },
    "/git/list-checkpoints": {
      "get": {
        "description": "List active checkpoints. List of checkpoint info dicts with 'name' and 'type' keys",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List active checkpoints",
        "tags": [
          "git"
        ]
      }
    },
    "/git/merge-checkpoint": {
      "post": {
        "description": "Merge checkpoint changes into base branch. Dict with 'commit' SHA of merge commit",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "message": {
                    "description": "Optional merge commit message",
                    "type": "string"
                  },
                  "name": {
                    "description": "Checkpoint branch name to merge",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Merge checkpoint changes into base branch",
        "tags": [
          "git"
        ]
      }
    },
    "/git_hotspots/analyze": {
      "get": {
        "description": "Analyze git history for hot spots. GitHotspotAnalysis with frequently changed files",
        "parameters": [
          {
            "description": "Number of days to analyze (default: 90)",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze git history for hot spots",
        "tags": [
          "git_hotspots"
        ]
      }
    },
    "/git_hotspots/get-top-hotspots": {
      "get": {
        "description": "Get the top N most frequently changed files. List of hotspot details for most frequently changed files",
        "parameters": [
          {
            "description": "Number of days to analyze",
            "in": "query",
            "name": "days",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of files to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get the top N most frequently changed files",
        "tags": [
          "git_hotspots"
        ]
      }
    },
    "/guessability/analyze": {
      "get": {
        "description": "Analyze codebase guessability. Evaluates: - Name-content alignment: Do module names reflect their contents? - Predictability: Are similar things in similar places? - Pattern consistency: Are conventions followed? GuessabilityReport with scores and recommendations",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze codebase guessability",
        "tags": [
          "guessability"
        ]
      }
    },
    "/guessability/recommendations": {
      "post": {
        "description": "Get guessability improvement recommendations. List of actionable recommendations",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get guessability improvement recommendations",
        "tags": [
          "guessability"
        ]
      }
    },
    "/guessability/score": {
      "post": {
        "description": "Get overall guessability score. GuessabilityScore with 'score' (0.0-1.0) and 'grade' (A-F)",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get overall guessability score",
        "tags": [
          "guessability"
        ]
      }
    },
    "/health/analyze-structure": {
      "get": {
        "description": "Analyze structural code quality. StructuralAnalysis with hotspots and metrics",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze structural code quality",
        "tags": [
          "health"
        ]
      }
    },
    "/health/analyze-tests": {
      "get": {
        "description": "Analyze test coverage structure. TestAnalysis with module-test mappings",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze test coverage structure",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check": {
      "get": {
        "description": "Run full health analysis on the project. ProjectStatus with health score, grade, and detailed metrics",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run full health analysis on the project",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check-docs": {
      "get": {
        "description": "Check documentation health. DocCheckResult with coverage and issues",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check documentation health",
        "tags": [
          "health"
        ]
      }
    },
    "/health/check-todos": {
      "get": {
        "description": "Check TODO tracking health. TodoCheckResult with tracked and orphaned TODOs",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check TODO tracking health",
        "tags": [
          "health"
        ]
      }
    },
    "/health/summarize": {
      "get": {
        "description": "Generate a project summary. ProjectSummary with module information",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Generate a project summary",
        "tags": [
          "health"
        ]
      }
    },
    "/patch/apply": {
      "post": {
        "description": "Apply a patch to a file. PatchResult with success status and modified content",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file to patch",
                    "type": "string"
                  },
                  "patch": {
                    "description": "Patch object describing the change",
                    "type": "string"
                  },
                  "write": {
                    "default": true,
                    "description": "Whether to write changes to disk",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path",
                  "patch"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Apply a patch to a file",
        "tags": [
          "patch"
        ]
      }
    },
    "/patch/apply-with-fallback": {
      "post": {
        "description": "Apply a patch with automatic text fallback. First tries AST-aware patching, falls back to text-based if that fails. PatchResult with success status and modified content",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file to patch",
                    "type": "string"
                  },
                  "patch": {
                    "description": "Patch object describing the change",
                    "type": "string"
                  },
                  "write": {
                    "default": true,
                    "description": "Whether to write changes to disk",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path",
                  "patch"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Apply a patch with automatic text fallback",
        "tags": [
          "patch"
        ]
      }
    },
    "/patch/create": {
      "post": {
        "description": "Create a Patch object. Patch object ready for application",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "anchor_name": {
                    "description": "Name of the anchor to target",
                    "type": "string"
                  },
                  "content": {
                    "description": "New content for the patch",
                    "type": "string"
                  },
                  "kwargs": {
                    "description": "",
                    "type": "string"
                  },
                  "patch_type": {
                    "description": "Type of patch - \"insert_before\", \"insert_after\", \"replace\", \"delete\"",
                    "type": "string"
                  }
                },
                "required": [
                  "patch_type",
                  "anchor_name",
                  "content",
                  "kwargs"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a Patch object",
        "tags": [
          "patch"
        ]
      }
    },
    "/rag/clear": {
      "post": {
        "description": "Clear the index. Dict with 'success' boolean",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Clear the index",
        "tags": [
          "rag"
        ]
      }
    },
    "/rag/index": {
      "post": {
        "description": "Index files for semantic search. Number of chunks indexed",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "force": {
                    "default": false,
                    "description": "Re-index even if content hasn't changed",
                    "type": "boolean"
                  },
                  "path": {
                    "description": "Directory to index (defaults to project root)",
                    "type": "string"
                  },
                  "patterns": {
                    "description": "Glob patterns to include (default: code and docs)",
                    "type": "array"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Index files for semantic search",
        "tags": [
          "rag"
        ]
      }
    },
    "/rag/search": {
      "post": {
        "description": "Search the index with natural language or code queries. List of SearchResult objects with file paths, scores, and snippets",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "kind": {
                    "description": "Filter by symbol kind (e.g., \"function\", \"class\", \"module\")",
                    "type": "string"
                  },
                  "limit": {
                    "default": 10,
                    "description": "Maximum results to return",
                    "type": "integer"
                  },
                  "mode": {
                    "default": "hybrid",
                    "description": "Search mode - \"hybrid\", \"embedding\", or \"tfidf\"",
                    "type": "string"
                  },
                  "query": {
                    "description": "Natural language or code query",
                    "type": "string"
                  }
                },
                "required": [
                  "query"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Search the index with natural language or code queries",
        "tags": [
          "rag"
        ]
      }
    },
    "/rag/stats": {
      "post": {
        "description": "Get index statistics. IndexStats with document count, files indexed, and backend info",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get index statistics",
        "tags": [
          "rag"
        ]
      }
    },
    "/ref_check/check": {
      "get": {
        "description": "Run bidirectional reference check. RefCheckResult with valid, broken, and stale references",
        "parameters": [
          {
            "description": "Warn if target modified more than N days after source",
            "in": "query",
            "name": "staleness_days",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run bidirectional reference check",
        "tags": [
          "ref_check"
        ]
      }
    },
    "/ref_check/check-code-to-docs": {
      "get": {
        "description": "Check only code-to-documentation references. List of broken code->doc references",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check only code-to-documentation references",
        "tags": [
          "ref_check"
        ]
      }
    },
    "/ref_check/check-docs-to-code": {
      "get": {
        "description": "Check only documentation-to-code references. List of broken doc->code references",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Check only documentation-to-code references",
        "tags": [
          "ref_check"
        ]
      }
    },
    "/search/find-definitions": {
      "get": {
        "description": "Find where a symbol is defined. Shortcut for find_symbols with exact matching. List of SymbolMatch objects for definitions",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "kind": {
                    "description": "Filter by kind: function, class, method",
                    "type": "string"
                  },
                  "name": {
                    "description": "Exact symbol name to find",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find where a symbol is defined",
        "tags": [
          "search"
        ]
      }
    },
    "/search/find-files": {
      "get": {
        "description": "Find files matching a glob pattern. List of relative file paths matching the pattern",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "limit": {
                    "default": 100,
                    "description": "Maximum number of results to return",
                    "type": "integer"
                  },
                  "path": {
                    "description": "Directory to search in (defaults to project root)",
                    "type": "string"
                  },
                  "pattern": {
                    "description": "Glob pattern (e.g., \"**/*.py\", \"src/**/*.ts\")",
                    "type": "string"
                  }
                },
                "required": [
                  "pattern"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find files matching a glob pattern",
        "tags": [
          "search"
        ]
      }
    },
    "/search/find-symbols": {
      "get": {
        "description": "Find symbols by name across the codebase. Searches all Python files for functions, classes, methods, and variables matching the given name. List of SymbolMatch objects sorted by relevance",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "fuzzy": {
                    "default": true,
                    "description": "If True, match partial names; if False, exact match only",
                    "type": "boolean"
                  },
                  "kind": {
                    "description": "Filter by kind: function, class, method, variable",
                    "type": "string"
                  },
                  "limit": {
                    "default": 50,
                    "description": "Maximum number of results to return",
                    "type": "integer"
                  },
                  "name": {
                    "description": "Symbol name to search for (supports partial matching)",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find symbols by name across the codebase",
        "tags": [
          "search"
        ]
      }
    },
    "/search/find-usages": {
      "get": {
        "description": "Find usages of a symbol in the codebase. Searches for references to a symbol name, optionally excluding the definition sites. GrepResult with usage locations",
        "parameters": [
          {
            "description": "Symbol name to find usages of",
            "in": "query",
            "name": "name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "If True, exclude definition lines",
            "in": "query",
            "name": "exclude_definitions",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Maximum number of results to return",
            "in": "query",
            "name": "limit",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Find usages of a symbol in the codebase",
        "tags": [
          "search"
        ]
      }
    },
    "/search/grep": {
      "post": {
        "description": "Search for text patterns in files. Uses regex pattern matching to find text in files. Similar to grep/ripgrep but integrated with Moss. GrepResult with matches and statistics",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "context_lines": {
                    "default": 0,
                    "description": "Number of context lines before/after match",
                    "type": "integer"
                  },
                  "glob": {
                    "description": "Glob pattern to filter files (e.g., \"*.py\", \"**/*.ts\")",
                    "type": "string"
                  },
                  "ignore_case": {
                    "default": false,
                    "description": "If True, perform case-insensitive matching",
                    "type": "boolean"
                  },
                  "limit": {
                    "default": 100,
                    "description": "Maximum number of matches to return",
                    "type": "integer"
                  },
                  "path": {
                    "description": "Directory to search in (defaults to project root)",
                    "type": "string"
                  },
                  "pattern": {
                    "description": "Regex pattern to search for",
                    "type": "string"
                  }
                },
                "required": [
                  "pattern"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Search for text patterns in files",
        "tags": [
          "search"
        ]
      }
    },
    "/search/resolve-file": {
      "get": {
        "description": "Resolve a file name with DWIM (Do What I Mean). Handles typos, missing extensions, and partial paths. FileMatch with resolved path and confidence",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "extensions": {
                    "description": "Extensions to try if name has none (default: .py, .ts, .js, .tsx, .jsx)",
                    "type": "array"
                  },
                  "name": {
                    "description": "File name, partial path, or module name to resolve",
                    "type": "string"
                  }
                },
                "required": [
                  "name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Resolve a file name with DWIM (Do What I Mean)",
        "tags": [
          "search"
        ]
      }
    },
    "/security/analyze": {
      "get": {
        "description": "Run security analysis. SecurityAnalysis with findings and summary",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "min_severity": {
                    "default": "low",
                    "description": "Minimum severity to report (\"low\", \"medium\", \"high\", \"critical\")",
                    "type": "string"
                  },
                  "tools": {
                    "description": "List of tools to use (None = all available)",
                    "type": "array"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Run security analysis",
        "tags": [
          "security"
        ]
      }
    },
    "/security/get-high-severity": {
      "get": {
        "description": "Get high and critical severity findings. List of high/critical security findings",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get high and critical severity findings",
        "tags": [
          "security"
        ]
      }
    },
    "/skeleton/expand": {
      "post": {
        "description": "Get the full source code of a named symbol. Useful for getting complete enum definitions, class bodies, or function implementations when the skeleton isn't enough. Full source code of the symbol, or None if not found # Get full enum definition content = api.skeleton.expand(\"src/agent_loop.py\", \"StepType\") # Returns complete enum with all values",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file",
                    "type": "string"
                  },
                  "symbol_name": {
                    "description": "Name of the symbol to expand (e.g., \"StepType\", \"my_function\")",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "symbol_name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Get the full source code of a named symbol",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/skeleton/extract": {
      "post": {
        "description": "Extract skeleton from a Python file. List of Symbol objects representing the code structure Note: For non-Python files, use format() which routes through the plugin system.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the Python file (relative to root or absolute)",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract skeleton from a Python file",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/skeleton/format": {
      "post": {
        "description": "Extract and format skeleton as readable text. Uses the plugin registry to support multiple file types (Python, Markdown, etc.). Formatted string representation of the skeleton",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to the file",
                    "type": "string"
                  },
                  "include_docstrings": {
                    "default": true,
                    "description": "Whether to include docstrings in output (Python only)",
                    "type": "boolean"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract and format skeleton as readable text",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/skeleton/get-enum-values": {
      "get": {
        "description": "Extract enum member names from an Enum class. List of enum member names, or None if not found values = api.skeleton.get_enum_values(\"src/agent_loop.py\", \"StepType\") # Returns: [\"TOOL\", \"LLM\", \"HYBRID\"]",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "enum_name": {
                    "description": "Name of the Enum class",
                    "type": "string"
                  },
                  "file_path": {
                    "description": "Path to the Python file",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path",
                  "enum_name"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract enum member names from an Enum class",
        "tags": [
          "skeleton"
        ]
      }
    },
    "/todo/list": {
      "get": {
        "description": "List TODOs, optionally filtered by section. TodoListResult with items grouped by section",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "include_done": {
                    "default": false,
                    "description": "Include completed TODOs (default: False)",
                    "type": "boolean"
                  },
                  "per_section_limit": {
                    "default": 5,
                    "description": "Max items to show per section (default: 5)",
                    "type": "integer"
                  },
                  "section": {
                    "description": "Filter to specific section (case-insensitive partial match)",
                    "type": "string"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List TODOs, optionally filtered by section",
        "tags": [
          "todo"
        ]
      }
    },
    "/todo/search": {
      "post": {
        "description": "Search TODOs by keyword. List of TodoSearchResult with matching items, sorted by relevance",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "include_done": {
                    "default": false,
                    "description": "Include completed TODOs (default: False)",
                    "type": "boolean"
                  },
                  "query": {
                    "description": "Search query (case-insensitive, matches text and section)",
                    "type": "string"
                  }
                },
                "required": [
                  "query"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Search TODOs by keyword",
        "tags": [
          "todo"
        ]
      }
    },
    "/todo/sections": {
      "post": {
        "description": "List all TODO sections with counts. List of dicts with section name, pending count, and done count",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "List all TODO sections with counts",
        "tags": [
          "todo"
        ]
      }
    },
    "/tree/format": {
      "post": {
        "description": "Generate and format tree as readable text. Formatted tree visualization",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "compact": {
                    "default": false,
                    "description": "If True, use token-efficient format",
                    "type": "boolean"
                  },
                  "path": {
                    "description": "Directory to visualize (default: project root)",
                    "type": "string"
                  },
                  "tracked_only": {
                    "default": false,
                    "description": "If True, only show git-tracked files",
                    "type": "boolean"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Generate and format tree as readable text",
        "tags": [
          "tree"
        ]
      }
    },
    "/tree/generate": {
      "post": {
        "description": "Generate a tree visualization of a directory. TreeResult with tree visualization and file counts",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "gitignore": {
                    "default": true,
                    "description": "If True, respect .gitignore when showing all files",
                    "type": "boolean"
                  },
                  "path": {
                    "description": "Directory to visualize (default: project root)",
                    "type": "string"
                  },
                  "tracked_only": {
                    "default": false,
                    "description": "If True, only show git-tracked files",
                    "type": "boolean"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Generate a tree visualization of a directory",
        "tags": [
          "tree"
        ]
      }
    },
    "/validation/create-chain": {
      "post": {
        "description": "Create a standard Python validator chain. ValidatorChain configured for Python (syntax + ruff + pytest)",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Create a standard Python validator chain",
        "tags": [
          "validation"
        ]
      }
    },
    "/validation/validate": {
      "post": {
        "description": "Validate a Python file with the default chain. ValidationResult with any issues found",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "file_path": {
                    "description": "Path to validate",
                    "type": "string"
                  }
                },
                "required": [
                  "file_path"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Validate a Python file with the default chain",
        "tags": [
          "validation"
        ]
      }
    },
    "/weaknesses/analyze": {
      "get": {
        "description": "Analyze codebase for architectural weaknesses. WeaknessAnalysis with detected weaknesses",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "categories": {
                    "description": "Categories to check (None = all)",
                    "type": "array"
                  }
                },
                "required": [],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Analyze codebase for architectural weaknesses",
        "tags": [
          "weaknesses"
        ]
      }
    },
    "/weaknesses/format": {
      "post": {
        "description": "Format weakness analysis as markdown. Markdown-formatted report",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "analysis": {
                    "description": "WeaknessAnalysis to format",
                    "type": "string"
                  }
                },
                "required": [
                  "analysis"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Format weakness analysis as markdown",
        "tags": [
          "weaknesses"
        ]
      }
    },
    "/web/clear-cache": {
      "post": {
        "description": "Clear the web content cache. Number of cached items cleared",
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Clear the web content cache",
        "tags": [
          "web"
        ]
      }
    },
    "/web/extract-content": {
      "post": {
        "description": "Extract clean content from HTML string. Dict with title, text, token_estimate, metadata",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "html": {
                    "description": "Raw HTML content",
                    "type": "string"
                  },
                  "url": {
                    "default": "",
                    "description": "Optional URL for metadata",
                    "type": "string"
                  }
                },
                "required": [
                  "html"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Extract clean content from HTML string",
        "tags": [
          "web"
        ]
      }
    },
    "/web/fetch": {
      "post": {
        "description": "Fetch and extract content from URL. Dict with url, title, text, token_estimate, metadata",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "extract_main": {
                    "default": true,
                    "description": "Extract main content vs full page (default: True)",
                    "type": "boolean"
                  },
                  "url": {
                    "description": "URL to fetch",
                    "type": "string"
                  },
                  "use_cache": {
                    "default": true,
                    "description": "Check cache first (default: True)",
                    "type": "boolean"
                  }
                },
                "required": [
                  "url"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Fetch and extract content from URL",
        "tags": [
          "web"
        ]
      }
    },
    "/web/search": {
      "post": {
        "description": "Search the web with token-efficient results. Dict with query, results list, and compact string representation",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "properties": {
                  "max_results": {
                    "default": 5,
                    "description": "Maximum number of results (default: 5)",
                    "type": "integer"
                  },
                  "query": {
                    "description": "Search query",
                    "type": "string"
                  }
                },
                "required": [
                  "query"
                ],
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful response"
          }
        },
        "summary": "Search the web with token-efficient results",
        "tags": [
          "web"
        ]
      }
    }
  },
  "tags": [
    {
      "description": "API for code skeleton extraction. Extracts structural summaries of code (classes, functions, signatures) without implementation details. Supports multiple languages via plugin system.",
      "name": "skeleton"
    },
    {
      "description": "API for git-aware file tree visualization. Shows project structure with awareness of git tracking status.",
      "name": "tree"
    },
    {
      "description": "API for finding code locations using fuzzy anchors. Anchors identify code elements (functions, classes, variables) by name and type, with fuzzy matching support.",
      "name": "anchor"
    },
    {
      "description": "API for applying code patches. Supports AST-aware patching with automatic fallback to text-based patching when AST parsing fails.",
      "name": "patch"
    },
    {
      "description": "API for dependency analysis. Analyzes import/export relationships, detects circular dependencies, and provides coupling metrics.",
      "name": "dependencies"
    },
    {
      "description": "API for control flow graph analysis. Builds control flow graphs showing execution paths through functions.",
      "name": "cfg"
    },
    {
      "description": "API for code validation. Runs validators (syntax, linting, tests) and reports issues.",
      "name": "validation"
    },
    {
      "description": "API for shadow git operations. Provides atomic commit/rollback operations for safe code modifications.",
      "name": "git"
    },
    {
      "description": "API for context compilation. Compiles code views (skeletons, CFGs, dependencies) into structured context for AI consumption.",
      "name": "context"
    },
    {
      "description": "API for project health analysis. Provides comprehensive project health metrics and reports.",
      "name": "health"
    },
    {
      "description": "API for TODO management and search. Search and browse TODOs from TODO.md. Useful for finding relevant work items and understanding project priorities.",
      "name": "todo"
    },
    {
      "description": "START HERE - Tool discovery and routing for Moss. Don't know which Moss tool to use? Ask DWIM! This API helps you find the right tool for any task using natural language queries. Features: - Natural language queries: describe what you want, get tool suggestions - Semantic aliases: map conceptual names to canonical tools - Fuzzy matching: handle typos and variations - Confidence scoring: know when to auto-correct vs suggest",
      "name": "dwim"
    },
    {
      "description": "API for cyclomatic complexity analysis. Calculates McCabe cyclomatic complexity for Python functions, helping identify code that may be difficult to test or maintain.",
      "name": "complexity"
    },
    {
      "description": "API for structural clone detection. Detects structurally similar code by normalizing AST subtrees and comparing hashes. Helps identify code that could potentially be abstracted into shared functions.",
      "name": "clones"
    },
    {
      "description": "API for security analysis. Orchestrates multiple security tools (bandit, semgrep) to detect vulnerabilities and security issues in the codebase.",
      "name": "security"
    },
    {
      "description": "API for bidirectional reference checking. Validates that code files reference their documentation and documentation references implementation files. Detects stale references where targets have been modified after sources.",
      "name": "ref_check"
    },
    {
      "description": "API for git hotspot analysis. Identifies frequently changed files in the git repository. High churn areas may indicate code that needs refactoring.",
      "name": "git_hotspots"
    },
    {
      "description": "API for external dependency analysis. Analyzes PyPI/npm dependencies including transitive dependencies, security vulnerabilities, and license compatibility.",
      "name": "external_deps"
    },
    {
      "description": "API for architectural weakness analysis. Identifies potential issues in codebase architecture: - Tight coupling between components - Missing abstractions - Inconsistent patterns - Technical debt indicators",
      "name": "weaknesses"
    },
    {
      "description": "API for RAG (Retrieval-Augmented Generation) semantic search. Provides semantic code search capabilities using vector embeddings. Index your codebase once, then search with natural language queries.",
      "name": "rag"
    },
    {
      "description": "API for token-efficient web fetching and search. Provides web content extraction optimized for LLM context. Strips HTML noise, extracts main content, caches results. api = MossAPI.for_project(\".\") content = await api.web.fetch(\"https://docs.python.org/3/\") print(f\"Tokens: ~{content.token_estimate}\") results = await api.web.search(\"python asyncio tutorial\") print(results.to_compact())",
      "name": "web"
    },
    {
      "description": "API for codebase search operations. Provides unified search across the codebase using structural analysis (skeleton/anchors), text patterns (grep), and file patterns (glob). Use this instead of raw grep/glob for better integration with Moss.",
      "name": "search"
    },
    {
      "description": "API for evaluating codebase structure quality. Measures how intuitive and predictable the codebase structure is. Can you guess where to find functionality based on its name?",
      "name": "guessability"
    }
  ]
}
